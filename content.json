[{"title":"ver4.1.4 置顶文章更新","date":"2021-07-15T12:36:40.000Z","path":"2021/07/15/歡迎！/","text":"ver4.1.4概覽: 对,你没看错,这次更新什么内容都没有//-_-\\\\ 考试结束,新的文章会涉及到Vue商城的数据请求,数据使用,有需求的话就看下吧? 事实上考试前最后一个周日我已经完成了这个Vue商城的项目,它使用了BetterScroll来优化纵向拉动效果,并且涵盖了一个Vue项目该有的一切基本元素(除了vuex),而且封装的十分彻底,目测复用性应该很强,我想我会记述完这个Vue商城的项目,然后找一个基于element-ui的项目来做.","tags":[]},{"title":"Vue-cli4 alias配置","date":"2021-07-03T07:23:26.000Z","path":"2021/07/03/Vue-cli4 alias配置/","text":"Vue-cli4配置alias 配置别名首先依据如下路径找到base.js文件; 1node_modules&gt;@vue&gt;cli-service&gt;lib&gt;config&gt;base.js 然后找到如下: 123456789101112131415161718webpackConfig.resolve // This plugin can be removed once we switch to Webpack 6 .plugin(&#x27;pnp&#x27;) .use(&#123; ...require(&#x27;pnp-webpack-plugin&#x27;) &#125;) .end() .extensions .merge([&#x27;.mjs&#x27;, &#x27;.js&#x27;, &#x27;.jsx&#x27;, &#x27;.vue&#x27;, &#x27;.json&#x27;, &#x27;.wasm&#x27;]) .end() .modules .add(&#x27;node_modules&#x27;) .add(api.resolve(&#x27;node_modules&#x27;)) .add(resolveLocal(&#x27;node_modules&#x27;)) .end() .alias//alias:别名,在此处依据格式配置别名; .set(&#x27;@&#x27;, api.resolve(&#x27;src&#x27;)) .set(&#x27;assets&#x27;, api.resolve(&#x27;src/assets&#x27;)) .set(&#x27;components&#x27;, api.resolve(&#x27;src/components&#x27;)) .set(&#x27;views&#x27;, api.resolve(&#x27;src/views&#x27;))","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"Vue购物商城项目——TabBar制作","date":"2021-07-03T03:13:30.000Z","path":"2021/07/03/Vue3购物商城项目——TabBar/","text":"Vue购物商城项目 一、Cli4生成项目略略略;使用Vue-cli4.5x快速搭建项目头铁,全用最新版了;| 插件 | 版本 ||–|–|| Vue | ^3.0.0 || vue-router | ^4.0.0-0 || axios | ^0.21.1 || css-loader | ^3.6.0 || style-loader | ^1.1.3 |文章阶段性同步, 插件部分目前就用到了这些; 二、路由配置我想了一下,还是决定返回来先把路由写上,因为TabBarItem需要用到路由来判断高亮显示与否; 12345678910111213141516171819202122232425262728293031323334353637//这是在index.js里;import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;//cli4真的就只需要引入这俩了;const routes = [ &#123; path: &#x27;/&#x27;, name: &#x27;home&#x27;, component: () =&gt; import(&#x27;../views/home/Home.vue&#x27;) &#125;, &#123; path: &#x27;/classify&#x27;, name: &#x27;classify&#x27;, component: () =&gt; import(&#x27;../views/classify/classify.vue&#x27;) &#125;, &#123; path: &#x27;/shoppingcar&#x27;, name: &#x27;shoppingcar&#x27;, component: () =&gt; import(&#x27;../views/shoppingcar/shoppingcar.vue&#x27;) &#125;, &#123; path: &#x27;/my&#x27;, name: &#x27;my&#x27;, component: () =&gt; import(&#x27;../views/my/my.vue&#x27;) &#125;]/*我们一共有四个页面,需要四条路由; */const router = createRouter(&#123; history: createWebHistory(process.env.BASE_URL), routes /* 把路由表(就是上面的那个装着对象的数组)放在这里, 在下面一起导出,供组件使用 */&#125;)export default router/* 导出路由表 */ Cli4.x路由配置详解 三、tabBar制作我想你可能见过那种固定定位,不会随着页面滚动的底部横条?这部分共包括三个组件; TabBar TabBarItem MainTabBar TabBar和TabBarItem有插槽关系,TabBar有一个插槽, 在MainTabBar处可以传入所有的(4个)TabBarItem; 每个TabBarItem有三个插槽,在MainTabBar处可以传入各个TabBarItem的内容; 我们先看TabBar和TabBarItem, 封装完这两个我们才能封装MainTabBar; 2.TabBarItem组件考虑到我难以把说明对应到代码位置,下面的说明基本都写在代码注释里,如果你想要看某段代码的说明,请在这段代码下方寻找; template标签用来写组件模板,在Cli4里,根元素不再只能有唯一一个,你可以在里面写多个根元素(不过下面这个还是只写了一个tab-bar-item); 1234567891011121314151617181920212223242526272829//这是在src/components/common/tabbar/TabBarItem.vue里;&lt;template&gt; &lt;div class=&quot;tab-bar-item&quot;&gt; &lt;div&gt;&lt;slot name=&quot;item-icon&quot;&gt;&lt;/slot&gt;&lt;/div&gt; &lt;div&gt;&lt;slot name=&quot;item-icon-active&quot;&gt;&lt;/slot&gt;&lt;/div&gt; &lt;div&gt;&lt;slot name=&quot;item-text&quot;&gt;&lt;/slot&gt;&lt;/div&gt; /* 这里全部采用ver2.6.0后的具名插槽, 防止传入混乱导致的无法传入; */ &lt;/div&gt;&lt;/template&gt; /* 我们的每个TabBarItem都由三个插槽组成: item-icon需要被传入未点击时的图标 item-icon-active需要被传入点击时的高亮图标 item-text需要被传入一个放入了文本的div; */&lt;script&gt;/* 为了不影响浏览,控制未触发图标和高亮图标切换的代码写在下面了 */&lt;/script&gt;&lt;style scoped&gt;.tab-bar-item &#123; flex: 1; margin-left: 23px; text-align: center;&#125;&lt;/style&gt; 我们现在来完成TabBarItem图标点击高亮的功能,虽然图标还没传入,看不到效果; 四、MainTabBar组件不打算在项目里引入TabBar和TabBarItem就封装的彻底一点吧，到时候只引入MainTabBar就好了； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//这是在src/components/content/mainTabBar/MainTabBar.vue里;//这里的~assets是因为定义了别名,如果没有定义别名还是要中规中矩写...//四个对tabbaritem的插槽传入,因为结构都相同,注释只在前两个;&lt;template&gt; &lt;tab-bar&gt; /*从此处向下,到&lt;/tab-bar&gt;截止,都是给TabBar的插槽传的内容 */ &lt;router-link to=&quot;/&quot;&gt; &lt;tab-bar-item activeColor=&quot;rgba(4, 39, 238, 0.856)&quot;&gt; /* tab-bar-item:从此处开始到首个&lt;/tab-bar-item&gt;, 是给第一个tabbaritem的插槽传入的内容; */ /* activeColor:其值传给TabBarItem组件中的props, 必须是一个颜色值; */ &lt;template v-slot:item-icon&gt; &lt;img src=&quot;~assets/img/icon/Brightness.png&quot; /&gt; &lt;/template&gt; &lt;template v-slot:item-icon-active&gt; &lt;img src=&quot;~assets/img/icon/Brightness2.png&quot; /&gt; &lt;/template&gt; &lt;template v-slot:item-text&gt; &lt;div&gt;首页&lt;/div&gt; &lt;/template&gt; &lt;/tab-bar-item&gt; &lt;/router-link&gt; /* 我们需要分别给四个tabbaritem插槽传内容 */ &lt;router-link to=&quot;/classify&quot;&gt; &lt;tab-bar-item activeColor=&quot;rgba(4, 39, 238, 0.856)&quot;&gt; &lt;template v-slot:item-icon&gt; &lt;img src=&quot;~assets/img/icon/Gear.png&quot; /&gt; &lt;/template&gt; /* 还记得在做TabBarItem时的具名插槽吗? 你可以在这里规定这份template里的html要传到哪个插槽了, 嗯,用v-slot对应name属性; */ &lt;template v-slot:item-icon-active&gt; &lt;img src=&quot;~assets/img/icon/Gear2.png&quot; /&gt; &lt;/template&gt; &lt;template v-slot:item-text&gt; &lt;div&gt;分类&lt;/div&gt; &lt;/template&gt; &lt;/tab-bar-item&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/shoppingcar&quot;&gt; &lt;tab-bar-item activeColor=&quot;rgba(4, 39, 238, 0.856)&quot;&gt; &lt;template v-slot:item-icon&gt; &lt;img src=&quot;~assets/img/icon/unlock.png&quot; /&gt; &lt;/template&gt; &lt;template v-slot:item-icon-active&gt; &lt;img src=&quot;~assets/img/icon/Lock.png&quot; /&gt; &lt;/template&gt; &lt;template v-slot:item-text&gt; &lt;div&gt;购物车&lt;/div&gt; &lt;/template&gt; &lt;/tab-bar-item&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/my&quot;&gt; &lt;tab-bar-item activeColor=&quot;rgba(4, 39, 238, 0.856)&quot;&gt; &lt;template v-slot:item-icon&gt; &lt;img src=&quot;~assets/img/icon/Task.png&quot; /&gt; &lt;/template&gt; &lt;template v-slot:item-icon-active&gt; &lt;img src=&quot;~assets/img/icon/Task2.png&quot; /&gt; &lt;/template&gt; &lt;template v-slot:item-text&gt; &lt;div&gt;我的&lt;/div&gt; &lt;/template&gt; &lt;/tab-bar-item&gt; &lt;/router-link&gt; &lt;/tab-bar&gt; &lt;router-view /&gt; /* 把router-view写在template里, 不然就等着tabbar跑顶部去吧... */&lt;/template&gt;&lt;script&gt;import TabBar from &quot;components/common/tabbar/TabBar&quot;;import TabBarItem from &quot;components/common/tabbar/TabBarItem&quot;;export default &#123; name: &quot;App&quot;, components: &#123; TabBar, TabBarItem, &#125;,&#125;; /* 引入TabBar和TabBarItem,注册一下以备使用; */&lt;/script&gt;&lt;style&gt;/* 你可以在这里写文字的样式,router-link标签默认会被渲染成&lt;a&gt;标签; */&lt;/style&gt; 五、Icon路径 总结艰难的考试周ing…昨天收到”好消息”,我要留校培训到30号(痛苦面具) X目","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"Auto.js 60条常用命令&作用","date":"2021-06-22T15:28:43.000Z","path":"2021/06/22/Auto.js 60条常用命令 & 作用/","text":"Auto.js 常用命令及作用 对应用命令 命令 目的 app.versionCode 获取当前所在软件版本号 app.versionName 获取当前所在软件版本名 app.launchApp(应用名) 启动应用by应用名 app.launch(包名) 启动应用by包名 app.getAppName(包名) 获取应用包名对应的应用名 app.openUrl(URL) 打开某URL app.uninstall 卸载当前所在的应用 屏幕操作模拟 命令 目的 setScreenMetrics(宽, 高) 设置脚本运行时适用的屏幕尺寸(px),若实际尺寸不一致,脚本会缩放自身比例以求兼容 click(x, y) 模拟点击某位置 longClick(x, y) 模拟长按某位置,时间默认 press(x, y, 持续时长) 模拟长按,持续?ms swipe(起点x, 起点y, 终点x, 终点y, 滑动全程耗时) 模拟定时定位滑动手势 gesture(全程耗时, [点1x, 点1y], [点2x, 点2y], …) 模拟定时定位复杂滑动手势 屏幕按键监听 命令 目的 events.observeTouch() 屏幕按键监听,启动 !(需拿到root权限) events.setTouchEventTimeout(时间间隔) 设定两次触摸事件的最小间隔(ms) events.getTouchEventTimeout() 返回两次触摸事件的最小间隔(ms) events.onTouch(回调函数) 注册触摸回调函数,只要有屏幕触摸,就回调函数 events.removeAllTouchListeners() 移除全部屏幕触摸监听函数 events.on(“事件”,回调函数) 当有屏幕按键事件时会触发事件 Key 事件,有屏幕按键按下/弹起都会触发 key_up 事件,有屏幕按键弹起就触发 key_down 事件,有屏幕按键按下就触发 toast 事件,有应用弹出气泡就会触发 notification 事件,有应用发出通知会触发该事件 home 主屏幕键 back 返回 menu 菜单(运行中应用)","tags":[{"name":"Auto.js","slug":"Auto-js","permalink":"http://example.com/tags/Auto-js/"}]},{"title":"Vue-cli4 对路由配置的理解","date":"2021-06-19T12:11:45.000Z","path":"2021/06/19/Vue-cli4 对路由配置的理解/","text":"vue-cli4 路由配置 二、路由懒加载技术把不同的路由对应的组件分离,仅当某路由被触发时才会加载对应组件,会更加高效,并且第三方 &amp; 底层支撑 &amp; 公共App 除外, 其他的Vue页面组件都在服务器,随用随请求,确保对页面的影响最小. 其实就是改变一下router/index.js里对各个组件的引入方法啦……通过箭头函数的方法进行. 123456789101112131415161718192021const routes = [ &#123; path: &#x27;/about&#x27;, name: &#x27;About&#x27;, component: () =&gt; import(&#x27;../views/About.vue&#x27;) //直接在这里引入了About并且赋值给了component; &#125;, &#123; path: &#x27;/news&#x27;, name: &quot;News&quot;, component: () =&gt; import(&quot;../views/News.vue&quot;) //直接在这里引入了About并且赋值给了component; &#125;, &#123; path: &#x27;/login&#x27;, name: &#x27;Login&#x27;, component: () =&gt; import(&#x27;../views/Login.vue&#x27;) //直接在这里引入了About并且赋值给了component; &#125;,] 四、动态路由很多时候页面需要跳转到哪里是不能由我们写程序的来确定的,这就需要程序按照需求去自己决定,让路由得以动态改变. 1.动态路由配置说简单些,我们不把[to需要增加的URL]和[path判定跳转的URL]写死就好了,把URL里需要经常变化的部分,利用v-bind与export default中的data数据互通起来,让URL跟随数据变动. 12345678910111213141516//这是在router/index.jsimport &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;;const routes = [ &#123; path: &#x27;/&#x27;, name: &#x27;Home&#x27;, component: () =&gt; import(&#x27;../views/Home.vue&#x27;), &#125;, &#123; //我们在此处也不要把path的值写死; path: &#x27;/user/:userId&#x27;, name: &#x27;User&#x27;, component: () =&gt; import(&#x27;../views/User.vue&#x27;), &#125;]; 1234567891011121314151617181920212223&lt;!-- 这是在App.vue里 --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; | &lt;!-- 在此处使用v-bind将userId数据调用; --&gt; &lt;!-- 将/user/作为字符串拼接给userId --&gt; &lt;router-link v-bind:to=&quot;&#x27;/user/&#x27; + userId&quot;&gt;用户&lt;/router-link&gt; &lt;/div&gt; &lt;router-view /&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;app&quot;, data() &#123; return &#123; //在此处设定userId的数据为baixia; userId: &quot;baixia&quot;, &#125;; &#125;,&#125;;&lt;/script&gt; 来看下效果:接下来点击用户:URL成功拼接了了data里的数据UserId,即baixia. 2.动态路由传参动态路由也是Vue传递数据的方式之一,利用$route来进行Vue页面组件(即vue文件)间的通信.先来认识两个变量: $router: index.js末尾利用createRouter创建的路由对象 $route: 当前正处于活跃状态下的路由对象,其中有一个params属性,全称parameters,利用它,可以取到我们URL里使用v-bind传的值. 比如User.vue需要获取App.vue的data中的userId数据: 1234567891011121314151617&lt;!-- 在App.vue中(发方) --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link v-bind:to=&quot;&#x27;/user/&#x27; + userId&quot;&gt;用户&lt;/router-link&gt; &lt;/div&gt; &lt;router-view /&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;app&quot;, data() &#123; return &#123; userId: &quot;baixia&quot;, &#125;; &#125;,&#125;;&lt;/script&gt; 123456789101112//在user.vue中(收方)export default &#123; name:&quot;user&quot;, computed: &#123; userId() &#123; return this.$router.params.userId//将this.$router.param.userId的值,//即App.vue的router-link里传入的userId返回,//以作为计算属性userID()的值 &#125; &#125;&#125; User.vue里为了获取用户信息而使用的params,其获取哪个属性依赖于index.js里的path,的如果path:’/user/:abc’,那么User.vue的&lt; script&gt;里应当为: 123456789export default &#123; name:&quot;user&quot;, computed: &#123; userId() &#123; //这里也应为获取abc属性; return this.$router.params.abc &#125; &#125;&#125;","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! node-sass@","date":"2021-06-17T15:30:27.000Z","path":"2021/06/17/npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! node-sass@/","text":"npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! node-sass@ 问题描述：使用npm安装node-sass时报错: 123456npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! node-sass@4.14.1 postinstallnpm ERR! Exit status 1npm ERR!npm ERR! Failed at the node-sass@4.14.1 postinstall script. 解决方案：这里修改成了了taobao的npm 1npm config set sass_binary_site=https://npm.taobao.org/mirrors/node-sass 重新安装,解决: 1npm install","tags":[{"name":"Bug","slug":"Bug","permalink":"http://example.com/tags/Bug/"}]},{"title":"Node Sass version 6.0.0 is incompatible with ^4.0.0.","date":"2021-06-17T15:20:08.000Z","path":"2021/06/17/Node Sass version 6.0.0 is incompatible with ^4.0.0./","text":"Node Sass version 6.0.0 is incompatible with ^4.0.0. 问题描述：安装node-sass后npm run serve提示:Node Sass version 6.0.0 is incompatible with ^4.0.0. 解决方案尝试下载更低版本的node-sass,卸载原来的node-sass,使用了Ver 4.14.1的node-sass,问题解决; 1npm uni node-sass -D 1npm i node-sass@4.14.1 -D","tags":[{"name":"Bug","slug":"Bug","permalink":"http://example.com/tags/Bug/"}]},{"title":"解读箭头函数this指向","date":"2021-05-29T07:07:14.000Z","path":"2021/05/29/解读箭头函数this指向/","text":"解读箭头函数this指向 一、熟悉箭头函数箭头函数是ES6新增的语法,当准备把函数作为参数传递时,用箭头函数看起来会比较简洁,简洁,但是可读性略差(尤其是它被省略的根本不像个函数的时候). 1.传一个参数1234const 函数名 = 参数 =&gt; &#123; xxx函数体 xxx函数体&#125; 或 1234const 函数名 = (参数) =&gt; &#123; xxx函数体 xxx函数体&#125; 2.传多个参数1234const 函数名 = (参1,参2) =&gt; &#123;xxx函数体xxx函数体&#125; 总结","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"使用Vue-cli4.5.x快速搭建项目","date":"2021-05-29T05:51:12.000Z","path":"2021/05/29/使用vue-cli4.5.x快速搭建项目/","text":"使用Vue-cli4.5.x快速搭建项目 我不太适应ESLint,我这里就不逞能了……最下的单元测试(unit Testing)和端到端测试(E to E Testing),有需求的话就开; 4.单项配置选中第一项””Choose Vue version来进行单项配置:是否为vue-router启用HTML5的history模式?这个推荐启用,会让你的url更加整洁好看,可读性更高;在SPA页面中,不少方法会依赖于HTML5的history模式; 好的,你打算把这次构建项目的配置沿用到今后嘛?这个你自己决定喽……选择是的话,下次在执行第一步时就会出现第四个选项,那就是你自定义的配置方法. 5.选择包管理工具会让你选择是用npm还是yarn,我这里没有显示直接用了npm ,奇奇怪怪;选自己想用的就好. 至此创建完成.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"is a Vue CLI 3 only command and you are using Vue CLI 2.9.6. You may...","date":"2021-05-24T14:48:38.000Z","path":"2021/05/24/[Vue-cli3] is a Vue CLI 3 only command and you are using Vue CLI 2.9.6. You may.../","text":"is a Vue CLI 3 only command and you are using Vue CLI 2.9.6. You may… 项目场景：Vue-cli3执行生成脚手架,这个bug已解决; 原因分析：你可以忽略这部分直接看最下解决方案; 推测未成功安装,依据意见,以管理员权限运行cmd: 12345678910111213C:\\windows\\system32&gt;npm install -g @vue/clinpm WARN deprecated @hapi/joi@15.1.1: Switch to &#x27;npm install joi&#x27;npm WARN deprecated request@2.88.2: request has been deprecated, see https://github.com/request/request/issues/3142npm WARN deprecated @hapi/address@2.1.4: This version has been deprecated and is no longer supported or maintainednpm WARN deprecated @hapi/bourne@1.3.2: This version has been deprecated and is no longer supported or maintainednpm WARN deprecated @hapi/hoek@8.5.1: This version has been deprecated and is no longer supported or maintainednpm WARN deprecated @hapi/topo@3.1.6: This version has been deprecated and is no longer supported or maintainednpm WARN deprecated har-validator@5.1.5: this library is no longer supportednpm WARN deprecated resolve-url@0.2.1: https://github.com/lydell/resolve-url#deprecatednpm WARN deprecated urix@0.1.0: Please see https://github.com/lydell/urix#deprecatedD:\\toolkit\\node_global\\vue -&gt; D:\\toolkit\\node_global\\node_modules\\@vue\\cli\\bin\\vue.js+ @vue/cli@4.5.13updated 1 package in 56.355s 未报错; 再次执行vue create xxx,相同报错,未解决; 删除AppData的npm_cache文件,无效,删除后npm安装vuecli3开始报错npm ERR! code EPERM npm ERR! syscall unlink 已安装cnpm,推测为此导致的权限问题;尝试cnpm安装vuecli3,安装时抛出报告有不同: 1234567891011121314151617181920C:\\windows\\system32&gt;cnpm i @vue/cli -gDownloading @vue/cli to D:\\toolkit\\node_global\\node_modules\\@vue\\cli_tmpCopying D:\\toolkit\\node_global\\node_modules\\@vue\\cli_tmp\\_@vue_cli@4.5.13@@vue\\cli to D:\\toolkit\\node_global\\node_modules\\@vue\\cliInstalling @vue/cli&#x27;s dependencies to D:\\toolkit\\node_global\\node_modules\\@vue\\cli/node_modules[1/35] @types/ejs@^2.7.0 installed at node_modules\\_@types_ejs@2.7.0@@types\\ejs[2/35] commander@^2.20.0 installed at node_modules\\_commander@2.20.3@commander[3/35] deepmerge@^4.2.2 installed at node_modules\\_deepmerge@4.2.2@deepmerge[4/35] @vue/cli-ui-addon-widgets@^4.5.13 installed at node_modules\\_@vue_cli-ui-addon-widgets@4.5.13@@vue\\cli-ui-addon-widgets[5/35] debug@^4.1.0 installed at node_modules\\_debug@4.3.1@debug[6/35] @vue/cli-ui-addon-webpack@^4.5.13 installed at node_modules\\_@vue_cli-ui-addon-webpack@4.5.13@@vue\\cli-ui-addon-webpack[7/35] ejs@^2.7.1 installed at node_modules\\_ejs@2.7.4@ejs[8/35] envinfo@^7.5.1 installed at node_modules\\_envinfo@7.8.1@envinfo[9/35] cmd-shim@^3.0.3 installed at node_modules\\_cmd-shim@3.0.3@cmd-shim[10/35] ini@^1.3.5 installed at node_modules\\_ini@1.3.8@ini[11/35] boxen@^4.1.0 installed at node_modules\\_boxen@4.2.0@boxen[12/35] isbinaryfile@^4.0.6 installed at node_modules\\_isbinaryfile@4.0.8@isbinaryfile[13/35] fs-extra@^7.0.1 installed at node_modules\\_fs-extra@7.0.1@fs-extra[14/35] javascript-stringify@^1.6.0 installed at node_modules\\_javascript-stringify@1.6.0@javascript-stringify[15/35] import-global@^0.1.0 installed at node_modules\\_import-global@0.1.0@import-global//余部略; 未报错; 重启VSCode,尝试执行vue create xxx;不再报错npm ERR! code EPERM npm ERR! syscall unlink; 失败,相同报错s a Vue CLI 3 only command and you are using Vue CLI 2.9.6……; 检查vue -V,返回2.9.6,卸载无效,新版本安装未报错,推测覆盖失败;删除C:/用户/hp/.npmrc文件执行寻找:C:\\Users\\hp&gt;where vueC:\\Users\\hp\\AppData\\Roaming\\npm\\vueC:\\Users\\hp\\AppData\\Roaming\\npm\\vue.cmd删除上二文件; 再次执行全局卸载npm uninstall vue-cli -g,出现长时卡顿,等待from21:58;卡顿;等待to22:05:蚌埠住了,取消执行; 再执行from22:07;till22:10:fetchMetadata: sill resolveWithNewModule &#x6d;&#105;&#x6d;&#x65;&#45;&#100;&#x62;&#x40;&#x31;&#x2e;&#x34;&#55;&#46;&#48; checking installable status;尝试还原npm-cache文件夹至原位置,还原开始10s+后卸载执行完成,还原未完成,取消还原;推测checking installable status检索花费长时,非因缺失npm-cache内部文件; 卸载执行完毕,vue -V检查版本号;vue -V未检索到版本号,推测成功卸载; 开始尝试第5次执行全局安装vue-cli3.0;执行npm install -g @vue/cli from22:16;till22:20,等待长时卡顿中:fetchMetadata: sill resolveWithNewModule &#97;&#x6e;&#x73;&#105;&#x2d;&#114;&#101;&#103;&#101;&#120;&#x40;&#53;&#x2e;&#48;&#46;&#48; checking installable status;to22:28 卡顿,取消执行; 再执行cnpm install @vue/cli -g;完成at22:30;执行vue -V:@vue/cli 4.5.13;终止; VSCode重启执行vue create testvuecli3;生成配置文件;🎉 Successfully created project testvuecli3. At 22:35; 完毕 at 22:35;","tags":[{"name":"Bug","slug":"Bug","permalink":"http://example.com/tags/Bug/"}]},{"title":"WebPack配置文件抽离存放","date":"2021-05-24T07:16:34.000Z","path":"2021/05/24/WebPack配置文件抽离存放/","text":"WebPack配置文件的分离 一、安装插件&amp;配置通常会分离为三个文件,一个开发时依赖的配置文件(这里我命名为dev.config.js),一个发布时依赖的配置文件(这里我命名为prod.config.js),还有一个两模式下都需要依赖的配置文件(这里我命名为base.config.js); 安装插件没错,这个活webpack还是干不了.webpack-merge协助对两个配置文件进行合并. 1npm i webpack-merge -D 该插件在使用时需要导入: 1const webpackMerge = require(&#x27;webpack-merge&#x27;) 二、抽离存放抽离存放可以,但是用的时候也不能让webpack找不着; 1.分离配置文件123456789101112131415161718192021222324252627282930313233343536373839//这是webpack.config.js的内容module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;built.js&#x27;, path: resolve(__dirname, &#x27;build&#x27;) &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;, &#123; exclude: /\\.(css|js|html|less)$/, loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;[hash:10].[ext]&#x27; &#125;, &#125;, &#123; test: /\\.html$/, loader: &#x27;html-loader&#x27; &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;./src/index.html&#x27; &#125;) ], mode: &#x27;development&#x27;, devServer: &#123; contentBase: resolve(__dirname, &#x27;build&#x27;), compress: true, prop: 3000 &#125;&#125;; 仅生产环境下需要的配置放到prod.config.js 12345678//这是prod.config.js的内容module.exports = &#123; devServer: &#123; contentBase: resolve(__dirname, &#x27;build&#x27;), compress: true, prop: 3000 &#125;&#125; 开发环境&生产环境下均需要的配置放到base.config,js 1234567891011121314151617181920212223242526272829//这是base.config,js的内容module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;built.js&#x27;, path: resolve(__dirname, &#x27;build&#x27;) &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;, &#123; exclude: /\\.(css|js|html|less)$/, loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;[hash:10].[ext]&#x27; &#125;, &#125;, &#123; test: /\\.html$/, loader: &#x27;html-loader&#x27; &#125; ] &#125;, mode: &#x27;development&#x27;,&#125;; 到此,我们已经把webpack.config.js分开为三个文件,你可以删除原本的webpack.config.js了. baseConfig合并于prodConfig内,所以接下来仅需要进行dev.config.js和prodConfig的合并","tags":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"}]},{"title":"Webpack dev-server搭建本地服务","date":"2021-05-24T05:25:21.000Z","path":"2021/05/24/dev-server搭建本地服务/","text":"WebPack-dev-server搭建本地服务器 一、安装&amp;配置dev-server安装呼出终端输入指令; 1npm i webpack-dev-server -D 为了防止跟其他插件不兼容,还是记得规定下版本;这里不推荐高版本,会出现与webpack-cli不兼容;配置在webpack.config.js中添加devserver对象进行配置,对象内可设置属性:|属性| 作用 ||–|–|| contentBase | 为哪个文件夹提供服务,默认是webpack.config.js所在的根文件夹. ||port| 端口号,你可以在哪个端口看到效果,默认8080端口; ||inline| 是否实时监听,页面实时刷新,布尔值; ||historyApiFallback| 在SPA页面中.依赖HTML5的history模式; ||compress| 啓動gzip壓縮,讓代碼體型更小,速度更快,布尔值; |示例: 123456mode: &#x27;development&#x27;,devServer: &#123; contentBase: resolve(__dirname, &#x27;build&#x27;), compress: true, prop: 3000&#125; 二、使用dev-server我使用的是VSCode,在终端启用本地服务:webpack-dev-server(更高版本使用npx webpack-dev-server或npx webpack serve); 在package.json中设置”dev”:”webpack-dev-server –open”这样启动本地服务只需:npm run dev,启动服务同时会直接打开浏览器显示效果.当然去掉”–open”也可以,不会自启浏览器,启动仍可以简化成npm run dev;","tags":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"}]},{"title":"Auto.js 控件属性缺失时获取控件","date":"2021-05-22T16:24:12.000Z","path":"2021/05/23/Auto.js 控件属性缺失时获取控件/","text":"Auto.js 在控件属性缺失情况下获取控件 群里有很多新人问,各种既没有id也没有text的控件无法获取的问题. 使用环境我们在使用Auto.js Pro进行脚本开发时经常遇到多个页面控件(甚至所有)无id无text,我一开始也很懵,直接使用click()方法又显得很low.但他们的className通常是有的,而且会重名.其他属性也会有不同.","tags":[{"name":"Auto.js","slug":"Auto-js","permalink":"http://example.com/tags/Auto-js/"}]},{"title":"使用WebPack打包CSS文件","date":"2021-05-15T13:37:05.000Z","path":"2021/05/15/使用WebPack打包CSS文件/","text":"使用WebPack打包CSS文件 一、建立并配置文件webpack.config.js配置文件webpack.config.js用于为webpack分派工作(应该说是告诉它怎么做这个事儿);这个文件大致分成前后两部分,前面各种语句利用Node来获取module exports中需要的属性值之类;后一部分就是module exports这个对象(commonJS使用module exports进行暴露),这个对象是webpack的”工作指南”. 2.引入NodeJS模块获取绝对路径我们需要用绝对路径.不能直接写绝对路径,这里的绝对路径会用于生成webpack处理完后文件的输出路径,如果将来我们对文件路径做出改动,原来的绝对路径会导致输出的位置太远不好被项目中的其他文件引用,或者更惨一点原来的路径断了,打包完根本输出不出来.我们需要一个能跟随webpack.config.js的位置动态改变的绝对路径.Node中有一个path模块,我们可以引入它来提取resolve,resolve是一个方法,专门用于拼接绝对路径.直接在webpack.config,js中写入: 1const &#123;resolve&#125; = require(&#x27;path&#x27;); 之后我们就可以在module exports对象中使用resolve()方法了. 总结提示：这里对文章进行总结：例如：以上就是今天要讲的内容，本文仅仅简单介绍了pandas的使用，而pandas提供了大量能使我们快速便捷地处理数据的函数和方法。","tags":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"}]},{"title":"Webpack執行打包:You may need an appropriate loader to handle this file type","date":"2021-05-10T06:03:06.000Z","path":"2021/05/10/Webpack執行打包“You may need an appropriate loader to handle this file type“/","text":"Webpack執行打包:You may need an appropriate loader to handle this file type 问题描述：配置webpack.config.js完成;webpack &amp; webpack-cli安裝完成;css-loader &amp; style-loader安裝到上級文件夾完成,執行打包時輸入webpack顯示如下:也沒有生成Hash值“您或許需要loader來處理這種類型的文件”,但我已經安裝了正確的loader.","tags":[{"name":"Bug","slug":"Bug","permalink":"http://example.com/tags/Bug/"}]},{"title":"Vue组件化、组件通信的一些理解","date":"2021-04-25T14:34:23.000Z","path":"2021/04/25/Vue组件化、组件通信的理解/","text":"Vue组件化、组件通信的一些理解 甚麽是Vue组件，为甚麽采用组件化？我想，如果您已经接触过一些Vue组件化开发的基础知识，您便可以略过这段了。关于Vue组件：在开发过程中，如果把需要重复使用的一段框架封装起来，并且能在后面的使用中以极其简便的方式调用（自然是极少能遇到需要框架内容完全相同的情况，后面会有slot插槽的方法来改动需要变化的地方）一定会很方便，于是产生了“Vue组件”这一概念。听到上面说的Vue组件的用法，您会觉得它很像一种“模板”？其实Vue组件的构成中最重要的一部分就是模板属性“template”，它支持您在Vue组件模板对象中书写您需要的框架。关于组件化开发：其实组件的优点应该放在这里一并说，组件这一概念诞生后，服务器的压力相比以前已经有所改善，但是明显是仍有改进空间的：每个组件都要请求一份属于自己的数据，在数据更新后还要再次请求，出现事件要反馈…… 解决这个问题的途径便是将页面分割为一个个大组件，其内部装载各种子组件，如此一来，大组件只要在请求数据时把子组件的数据也都请求回来等着子组件调用即可，这就缩减了请求总次数。 一、在Vue组件间传输数据的目的前面说到父组件会在请求数据时顺带把子组件的数据也请求回来等待调用，那么既然子组件要调用，也就需要在Vue组件层面进行数据传输，子组件在自身事件触发后也要向服务器提交报告（内部包含触发的事件和触发事件的数据位置），这一过程也要经过父组件。 三、父级组件调用子级数据？也就是子传父，子组件需要向父组件提交其自身发生的事件，和事件发生的位置对应的数据，父组件才能判断下次请求什么数据。 通过v-on指令为子组件添加事件监听，子组件事件函数触发后调用其自身内部的”$emit”方法(子传父开始)， $emit方法内的自定义事件被触发，然后为父组件添加的针对 $emit内自定义事件的事件监听迅速监听到： $emit内的自定义事件被触发了，于是父组件马上开始执行针对这个自定义事件的事件函数来应对。这都不太重要，重要的是您需要的数据——在每一次事件函数被触发的时候，都会顺带传输一份携带数据的变量(这个变量通常是在子组件中存储数据的那个),传到最后一步的事件函数处，至此数据便进入父组件。 1234567891011121314151617181920212223242526272829const cpn = &#123; template: &#x27;#cpn&#x27;, data() &#123; return &#123; categories: [ &#123; id: &#x27;1&#x27;, name: &#x27;one&#x27; &#125;, &#123; id: &#x27;2&#x27;, name: &#x27;two&#x27; &#125; ] &#125; &#125;, methods: &#123; btnClick(item) &#123; this.$emit(&#x27;itemClick&#x27;, item) &#125; &#125;&#125;//Vue对象app挂载到id为app的DOM元素const app = new Vue(&#123; el: &quot;#app&quot;,//子组件在父组件app内部注册以成为其子组件; components: &#123; cpn &#125;, methods: &#123; cpnClick(item) &#123; console.log(&#x27;cpnClick&#x27;, item); &#125; &#125;&#125;) 在这个栗子中，cpn的data()中的数据被v-for提取到了item中，所以cpn是子组件(用谁的数据，谁就是本次通信的子组件)， 触发button上的点击事件后，btnClick函数被调用并传参item，此时btnClick中的$emit方法被调用，自定义事件itemClick被触发，并且传一个item； 然后itemClick这个自定义的事件会被父元素cpn的@itemClick=”cpnClick”监听到，并且触发cpnClick方法，item也会就此从 $emit 处，伴随itemClick事件的触发被传到cpnClick内，进入父元素，至此item传输完毕。","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"对前后端的理解","date":"2021-04-17T10:27:00.000Z","path":"2021/04/17/对前后端的初步理解/","text":"PHP与前端协作的理解（和PHP基础） 一、写在甚麽地方？怎么配合其他代码？1.在PHP文档里写PHP放在专门的后缀为“.php”的文件里。 2.在HTML文档里写PHP或者你可以把它放在你的前端HTML文档中但是你必须把它放在“”内部，只有那里面能写PHP代码,其他的各写各的，互不干扰，您只要记住php要写在这里面就好了。 像是这样： 1234567891011121314151617181920212223&lt;?php//连接数据库$link = mysql_connect(&quot;localhost&quot;, &quot;username&quot;, &quot;password&quot;)or die(&quot;Could not connect: &quot; . mysql_error());print (&quot;Connected successfully&quot;);//选择数据库mysql_select_db(&#x27;dbname&#x27;, $link) or die (&#x27;Can\\&#x27;t use db : &#x27; . mysql_error());//进行你想要的操作$a =123;?&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;发现I Do一刻&lt;/title&gt;&lt;link href=&quot;css/public.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;&lt;script src=&quot;Scripts/AC_RunActiveContent.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;?phpecho $a;?&gt;&lt;/body&gt;&lt;/html&gt; 3.在PHP文档里写HTML不太一样的是在PHP文档里对HTML框架进行填充时，要采用如下格式：‘HTML内容’ . PHP内容. ‘HTML’内容‘ 看着不太好明白，实际上就是HTML部分作为字符串的形式引入PHP文档中。PHP文档也能解析html代码,这些html代码会跟随着PHP文档在服务端执行。但是要填充HTML框架，HTML语法需要作为字符串和php语句进行字符串拼接，用php拿来的数据对HTML进行填充。在PHP中，字符串拼接使用小数点而不是加号。 ## 3.PHP 的 数组 PHP中两种数组： 1234//这是一个具有三个数组元素，使用array函数生成的普通数组; $数组名 = array(&#x27;ele1&#x27;, &#x27;ele2&#x27;,&#x27;ele3&#x27;); echo $数组名[索引号]; //输出数组中某个元素; print_r($数组名）; //输出一整个数组; 1234//这是一个具有三个数组元素，使用array函数生成的索引数组; $数组名 = array(&#x27;key1&#x27; =&gt; &#x27;value1&#x27;, &#x27;key2&#x27; =&gt; &#x27;value2&#x27;, &#x27;key3&#x27; =&gt; &#x27;value3&#x27;); echo $数组名[&#x27;key名&#x27;]; //输出数组中某个key对应的value; print_r($数组名）; //输出一整个数组; 以上是两种常用的数组类型，再此基础上还可拓展出二维数组、三维数组、再向更高维度的数组用的比较少了。 数组遍历从下面开始要涉及到“$ key 和 $ value”，这两个变量是为了好理解才命名为”key”和“value”的，数组内的key会经过$ key变量，而value会经过$ value变量，您尽可以把它们换成乱七八糟的名字，只要在那个位置有这么两个变量，循环就会知道该干什么。JS中的循环遍历数组提取数组内容的方法在PHP中依然存在使用for循环，或者foreach来进行。count()函数用在for遍历中，可以取到数组的长度。 1234//for循环遍历数组，count($数组名)表示取到该数组的元素个数;for($i = 0; $i &lt; count($数组名); $i++) &#123; echo $数组名[$i];&#125; foreach遍历： 12foreach ($数组名 as $value) //方法一;foreach($数组名 as $key =&gt; $value) //方法二; 第一种foreach方法遍历数组的原理：在遍历进行至每个索引单元（数组元素）时，都将这个索引单元的value（即键对应的值）赋值给变量$ value，并且数组内部的指针向前移一步来进入下一个索引单元。第二种foreach方法遍历数组的原理：在遍历进行至每个索引单元（数组元素）时，都将这个索引单元的key（即键名）赋值给变量$ key（这样说很难理解，其实$ key完全可以改成“$i”,相当于for循环中的 i），并且数组内部的指针向前移一步来进入下一个索引单元。 两种方法实际上一个是利用键来遍历，一个利用值来遍历。foreach输出索引数组的内容： 1234foreach($数组名 as $value) &#123; each $value.&quot;&lt;br&gt;&quot;;&#125;//数组的各个key对应的值value会被输出; 总结码了一个下午……您要是觉得还可以就点个赞吧 ：·）感觉写的还是有点粗略，因为我对PHP并没有太多研究，我举的例子有点以偏概全的感觉。以后有计划把HTML里写PHP获取HTML页面信息的那块仔细说说。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"v-for指令使用指南","date":"2021-04-15T05:07:19.000Z","path":"2021/04/15/v-for指令使用指南/","text":"v-for指令使用指南 与for循环的功能相似，以第一个元素作为模板生成后续，内部的子元素也会被生成。 一、v-for利用数组生成元素利用v-for从数组获取数据基本的模式：仅获取未做处理的数组元素： 1&lt;li v-for=&quot;用以获取数组元素的自定义变量 in 数组名&quot;&gt;&#123;&#123;用以获取数组元素的自定义变量&#125;&#125;&lt;/li&gt; 获取未处理的数组元素&amp;各自的索引号： 1&lt;li v-for=&quot;(用以获取数组元素的自定义变量，用来获取索引号的变量) in 数组名&quot;&gt;&#123;&#123;用以获取数组元素的自定义变量&#125;&#125;&#123;&#123;用来获取索引号的变量&#125;&#125;&lt;/li&gt; 先写个例子吧： 1234567891011121314151617181920&lt;!--纯数组arr、内部有对象的数组objArr--&gt; const app = new Vue(&#123; el: &#x27;ul&#x27;, data: &#123; arr: [1, 2, 3, 4, 5], objArr: [ &#123; id: 1, name: &#x27;a1&#x27;, hobby: &#x27;a2&#x27;, &#125;, &#123; id: 2, name: &#x27;b1&#x27;, hobby: &#x27;b2&#x27;, &#125;, &#x27;meaasge1&#x27; ] &#125; &#125;) 一、直接获取数组内的元素这意味着数组内的对象会直接被整个提取出来： 123&lt;ul&gt; &lt;li v-for=&quot;item in objArr&quot;&gt;&#123;&#123;i&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 123&lt;ul&gt; &lt;li v-for=&quot;i in objArr&quot;&gt;&#123;&#123;i&#125;&#125;&lt;/li&gt;&lt;/ul&gt; “in”前面的变量相当于for循环中的i，是可以自定义的，以上两段代码输出结果同为： 二、获取数组内对象的属性值可以看到在上面的i里我们已经获取到了数组objArr里的所有元素，那么只需要在插值表达式上做些改动即可： 1234&lt;ul&gt; &lt;li v-for=&quot;i in objArr&quot;&gt;&#123;&#123;i.name&#125;&#125;&lt;/li&gt; //获取所有对象里的name属性;&lt;/ul&gt; 三、获取数组元素的索引号Vue对象里的数组内本身具有索引号，但是要绑定到一个变量才能获取出来，每个数组元素都要绑定一个这个变量里的索引号，然后在获取这个数组元素的时候把与它绑定的索引号获取出来：绑定变量index到各个数组元素： 123&lt;ul&gt; &lt;li v-for=&quot;(i,ind) in objArr&quot;&gt;&#123;&#123;ind&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 123&lt;ul&gt; &lt;li v-for=&quot;(i,index) in objArr&quot;&gt;&#123;&#123;index&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 两个变量ind、index获取到的索引号是相同的： 二、v-for利用对象生成元素利用v-for从对象中获取数据基本的模式与从数组中获取很相似：仅获取属性值： 1&lt;li v-for=&quot;用以获取属性值的自定义变量 in 对象名&quot;&gt;&#123;&#123;用以获取属性值的自定义变量&#125;&#125;&lt;/li&gt; 获取属性值&amp;属性名： 1&lt;li v-for=&quot;(用以获取属性值的自定义变量,用以获取属性名的自定义变量) in 对象名&quot;&gt;&#123;&#123;用以获取属性值的自定义变量&#125;&#125;&#123;&#123;用以获取属性名的自定义变量&#125;&#125;&lt;/li&gt; 拿这个Vue对象作为例子吧： 123456789101112131415const app = new Vue(&#123; el: &#x27;ul&#x27;, data: &#123; obj1: &#123; id: 1, name: &#x27;a1&#x27;, hobby: &#x27;a2&#x27;, &#125;, obj2: &#123; id: 2, name: &#x27;b1&#x27;, hobby: &#x27;b2&#x27;, &#125;, &#125;&#125;) 一、仅获取对象中属性的值值通常比属性重要，所以第一个变量默认获取的是值。完成利用v-for对对象值的获取，意味着您可以在这个元素的插值表达式里使用这些对象值对应的变量，以此来把这些值填充进生成的元素里。 1234&lt;ul&gt; &lt;li v-for=&quot;value in obj1&quot;&gt;&#123;&#123;value&#125;&#125;&lt;/li&gt; //“value”所在的位置是一个可自定义变量名的变量。&lt;/ul&gt; 输出结果如下，为对象obj1里的三个属性值：二、获取对象中的属性值和属性名利用v-for获取对象中的属性名和属性值。这意味着您可以在这个元素的插值表达式内使用您获取到的属性名和属性值。 123 &lt;ul&gt; &lt;li v-for=&quot;(value,key) in obj1&quot;&gt;&#123;&#123;value&#125;&#125; &amp; &#123;&#123;key&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 此处value作为要用来获取对象属性值的变量；key作为用来获取属性名的变量；输出结果如下：","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"Webpack:“WARNING in configuration The ‘mode‘ option hasnot been set, webpack will fallback .... “","date":"2021-04-14T14:20:42.000Z","path":"2021/04/14/Webpack“WARNING in configuration The ‘mode‘ option hasnot been set, webpack will fallback .... “/","text":"Webpack:“WARNING in configuration The ‘mode‘ option hasnot been set, webpack will fallback …. “ 问题描述：配置webpack.config.js完成;webpack &amp; webpack-cli安裝完成;css-loader &amp; style-loader安裝到上級文件夾完成,執行打包時輸入webpack顯示如下:提示我沒有配置mode項 解决方案：解決方案一是剛開始用的,後來無意間發現了第二種:解決方案一:此時webpack為最新版5.36.2,需要在打包指令”webpack”后添加後綴 “–mode=development”來解決. 解決方案二:在使用一解決後我繼續完成後續工作,卡在css文件打包的問題上,最後我選取了webpack5.0.0webpack-cli3.3.12style-loader1.1.3css-loader3.6.0這一能配合webpack5.0.0的組合來進行最後的打包,發現在這種包組合下直接執行”webpack”即可進行正常打包.","tags":[{"name":"Bug","slug":"Bug","permalink":"http://example.com/tags/Bug/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Vue生命周期解析","date":"2021-04-14T14:20:42.000Z","path":"2021/04/14/Vue生命周期解析/","text":"Vue生命周期解析 前言升学，找工作，失业，找工作，买房，成家，一些人甚至至死都没能跑完这条人生的长路，他们的一生在奔波中度过，却不曾看到过一丝沿途的风景。 Vue是一个这样的人，在他短暂而被安排的明明白白的人生路途中，只剩下奔波，沿途的风景未能让他驻足一瞬，他创造的诸多美好，却从无法看哪怕是一眼。 狗头) 一、甚麽是[Vue的生命周期]？Vue的每个组件都是独立的，正因如此，Vue的每个组件也都有各自的生命周期（就像人的肺和肾都有自己的寿命），他们共同组成了[Vue的生命周期]。 Vue并不像人的生命周期一样有生老病死，如果Vue对象不被销毁，Vue会一直在那里，所以“生命周期”这个词在此处大可不必完全解读为“生命周期”原本的意思，知道是Vue创立后固定要做的那么些事儿就好了。 二、生命周期函数有时我们需要在Vue执行到某一步时，执行某些操作，那么可以利用这些生命周期函数来完成，把要执行的命令写进这些生命周期函数里，在Vue执行到这些函数的所在时，就会顺带完成你需要的操作，而我们首先要知道这些周期函数在什么时候会被执行、他们都是哪些。 1.beforeCreate在示例初始化、data observer配置和事件配置完成之间调用 2.created初始化依赖和注入，data初始化完毕，计算属性和event/watch事件进行回调后，DOM树挂载前。通常会在此处进行一部分网络请求。 3.beforeMount挂载前，创建虚拟el前，生成模板template后。 4.mounted挂载完成，DOM树渲染完毕后。 5.beforeDestoryVue实例销毁前。 6.destoryedVue所有子组件销毁后。 7.beforeUpdate数据data有更新，已被调用后。 8.updated虚拟DOM重新渲染发生变化的数据。 123456789101112131415161718192021222324252627282930Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const restoreActiveInstance = setActiveInstance(vm) vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) &#125; restoreActiveInstance() // update __vue__ reference if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125; // updated hook is called by the scheduler to ensure that children are // updated in a parent&#x27;s updated hook.&#125; 三、Vue的一生要做些甚麽？1.Vue对象创立，Vue出生。构造函数生成Vue实例； 1new Vue(); 2.初始化原步骤Init Event&Lifecycle;初始化事件相关：Event;初始化各生命周期函数：Lifecycle（也叫钩子函数）； 123import &#123; initEvents &#125; from &#x27;./events&#x27;import &#123; mark, measure &#125; from &#x27;../util/perf&#x27;import &#123; initLifecycle, callHook &#125; from &#x27;./lifecycle&#x27; 1234567891011121314151617181920212223242526//src/core/instance/lifecycle.jsexport function initLifecycle(vm: Component) &#123; const options = vm.$options // locate first non-abstract parent let parent = options.parent if (parent &amp;&amp; !options.abstract) &#123; while (parent.$options.abstract &amp;&amp; parent.$parent) &#123; parent = parent.$parent &#125; parent.$children.push(vm) &#125; vm.$parent = parent vm.$root = parent ? parent.$root : vm vm.$children = [] vm.$refs = &#123;&#125; vm._watcher = null vm._inactive = null vm._directInactive = false vm._isMounted = false vm._isDestroyed = false vm._isBeingDestroyed = false&#125; 以上为对生命周期函数lifecycle的初始化 12345678910//src/coreinstance/event.jsexport function initEvents (vm: Component) &#123; vm._events = Object.create(null) vm._hasHookEvent = false // init parent attached events const listeners = vm.$options._parentListeners if (listeners) &#123; updateComponentListeners(vm, listeners) &#125;&#125; 以上为对事件Event的初始化 123456789101112131415export function callHook(vm: Component, hook: string) &#123; // #7573 disable dep collection when invoking lifecycle hooks pushTarget() const handlers = vm.$options[hook] const info = `$&#123;hook&#125; hook` if (handlers) &#123; for (let i = 0, j = handlers.length; i &lt; j; i++) &#123; invokeWithErrorHandling(handlers[i], vm, null, vm, info) &#125; &#125; if (vm._hasHookEvent) &#123; vm.$emit(&#x27;hook:&#x27; + hook) &#125; popTarget()&#125; 以上为调用钩子函数Hook 2.5BeforeCreated函数调用生命周期函数BeforeCreated被调用。 12//src/core/instance/init.js callHook(vm, &#x27;beforeCreate&#x27;) 3.继续初始化原步骤Init injections &amp; reactivity &amp; state初始化依赖提供：provide；初始化依赖注入：injections；初始化Vue响应式的核心：reactivity ；provide提供依赖，提供的依赖可以是一个对象，或者是一个能返回对象的函数。依赖内包含了属性和属性值，属性值可以是一个对象。injections 注入依赖，在后代组件里使用 inject 选项来为其注入需要添加在这个实例上的属性，包含from和default默认值。reactivity系列是Vue响应式的核心。需要调用以上函数 1234567891011121314151617181920212223242526272829303132//src/core/instance/inject.jsexport function initProvide (vm: Component) &#123; const provide = vm.$options.provide if (provide) &#123; vm._provided = typeof provide === &#x27;function&#x27; ? provide.call(vm) : provide &#125;&#125;export function initInjections (vm: Component) &#123; const result = resolveInject(vm.$options.inject, vm) if (result) &#123; toggleObserving(false) Object.keys(result).forEach(key =&gt; &#123; /* istanbul ignore else */ if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; defineReactive(vm, key, result[key], () =&gt; &#123; warn( `Avoid mutating an injected value directly since the changes will be ` + `overwritten whenever the provided component re-renders. ` + `injection being mutated: &quot;$&#123;key&#125;&quot;`, vm ) &#125;) &#125; else &#123; defineReactive(vm, key, result[key]) &#125; &#125;) toggleObserving(true) &#125;&#125; 以上为初始化依赖提供provide与依赖注入injections 12345678910111213141516//src/core/instance/state.jsexport function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 以上为初始化state 3.5Create函数调用生命周期函数Create被调用。此段出自Vue源码文件”init.js” 4.判断el是否挂载了DOM没有挂载就挂载一个。有就直接下一步。watch事件回调this._init末的$mount函数运作。 12345678//src/platform/web/runtime/index.jsVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125; 以上为$mount函数的基本模型 123456789101112131415//src/platform/web/entry-runtime-with-compiler.jsVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; query(el) /* istanbul ignore if */ if (el === document.body || el === document.documentElement) &#123; process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn( `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.` ) return this &#125; 以上为Vue中的$mount函数被调用 1234567891011121314151617181920212223Vue.prototype.$watch = function ( expOrFn: string | Function, cb: any, options?: Object): Function &#123; const vm: Component = this if (isPlainObject(cb)) &#123; return createWatcher(vm, expOrFn, cb, options) &#125; options = options || &#123;&#125; options.user = true const watcher = new Watcher(vm, expOrFn, cb, options) if (options.immediate) &#123; try &#123; cb.call(vm, watcher.value) &#125; catch (error) &#123; handleError(error, vm, `callback for immediate watcher &quot;$&#123;watcher.expression&#125;&quot;`) &#125; &#125; return function unwatchFn () &#123; watcher.teardown() &#125;&#125; $watch被调用 5.判断是否有模板模板template作为模板占位符，用来包裹HTML元素，其不会被渲染到页面上，可以有三种写法：作为option属性写在Vue对象里、直接作为HTML标签、写在script标签里（第三个官方推荐写法,为script标签里的type属性赋值”x-template”）。有template模板把模板template转换为render函数（render函数会在后续渲染DOM中发挥作用）。无template模板将el挂载的对象的外层HTML作为模板template。没有对象就new一个啊（不是）this._init末的$mount函数运作完毕。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//src/platform/web/entry-runtime-with-compiler.js const options = this.$options // resolve template/el and convert to render function if (!options.render) &#123; let template = options.template if (template) &#123; if (typeof template === &#x27;string&#x27;) &#123; if (template.charAt(0) === &#x27;#&#x27;) &#123; template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !template) &#123; warn( `Template element not found or is empty: $&#123;options.template&#125;`, this ) &#125; &#125; &#125; else if (template.nodeType) &#123; template = template.innerHTML &#125; else &#123; if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; warn(&#x27;invalid template option:&#x27; + template, this) &#125; return this &#125; &#125; else if (el) &#123; template = getOuterHTML(el) &#125; if (template) &#123; /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(&#x27;compile&#x27;) &#125; const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123; outputSourceRange: process.env.NODE_ENV !== &#x27;production&#x27;, shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this) options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(&#x27;compile end&#x27;) measure(`vue $&#123;this._name&#125; compile`, &#x27;compile&#x27;, &#x27;compile end&#x27;) &#125; &#125; &#125; return mount.call(this, el, hydrating)&#125; 判断是否具有模板template，若是无模板template就将外层HTML转换为template; 5.5beforeMount函数调用生命周期函数beforeMount被调用。 5.6前面生成的render函数被调用render函数被调用来生成虚拟DOM，虚拟DOM是渲染好的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Vue.prototype._render = function (): VNode &#123; const vm: Component = this const &#123; render, _parentVnode &#125; = vm.$options if (_parentVnode) &#123; vm.$scopedSlots = normalizeScopedSlots( _parentVnode.data.scopedSlots, vm.$slots ) &#125; // set parent vnode. this allows render functions to have access // to the data on the placeholder node. vm.$vnode = _parentVnode // render self let vnode try &#123; vnode = render.call(vm._renderProxy, vm.$createElement) &#125; catch (e) &#123; handleError(e, vm, `render`) // return error render result, // or previous vnode to prevent render error causing blank component /* istanbul ignore else */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; vm.$options.renderError) &#123; try &#123; vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) &#125; catch (e) &#123; handleError(e, vm, `renderError`) vnode = vm._vnode &#125; &#125; else &#123; vnode = vm._vnode &#125; &#125; // if the returned array contains only a single node, allow it if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) &#123; vnode = vnode[0] &#125; // return empty vnode in case the render function errored out if (!(vnode instanceof VNode)) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; Array.isArray(vnode)) &#123; warn( &#x27;Multiple root nodes returned from render function. Render function &#x27; + &#x27;should return a single root node.&#x27;, vm ) &#125; vnode = createEmptyVNode() &#125; // set parent vnode.parent = _parentVnode return vnode&#125; 以上为对render函数的调用 6.虚拟el创建，DOM替换原步骤Create vm $el and replace “el” with it.Vue实例下的虚拟el创建，虚拟DOM替换原本的DOM。 -render方法在此处运作生成虚拟DOM对象。 6.5.DOM树渲染至页面完毕虚拟DOM挂载完毕，DOM树已经成功渲染至页面，页面已经具有样式，可以进行正常DOM操作。 7.Mounted函数调用。生命周期函数Mounted调用。 8.准备完毕Mounted状态如果在这个状态出现了数据更新需要再次渲染来更新页面：生命周期函数BeforeUpdate调用；虚拟DOM重新渲染，但仅以最小的DOM开支渲染发生变化的部分，其他部分复用，节省工作量。 9.Vue实例被请求销毁9.5BeforeDestory函数调用生命周期函数BeforeDestory调用。 10.清除各Vue组件清除watchers、child子组件、components和eventlistener事件监听 等等…… 12345678910111213141516171819202122232425262728293031323334353637383940414243 Vue.prototype.$destroy = function () &#123; const vm: Component = this if (vm._isBeingDestroyed) &#123; return &#125; callHook(vm, &#x27;beforeDestroy&#x27;) vm._isBeingDestroyed = true // remove self from parent const parent = vm.$parent if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) &#123; remove(parent.$children, vm) &#125; // teardown watchers if (vm._watcher) &#123; vm._watcher.teardown() &#125; let i = vm._watchers.length while (i--) &#123; vm._watchers[i].teardown() &#125; // remove reference from data ob // frozen object may not have observer. if (vm._data.__ob__) &#123; vm._data.__ob__.vmCount-- &#125; // call the last hook... vm._isDestroyed = true // invoke destroy hooks on current rendered tree vm.__patch__(vm._vnode, null) // fire destroyed hook callHook(vm, &#x27;destroyed&#x27;) // turn off all instance listeners. vm.$off() // remove __vue__ reference if (vm.$el) &#123; vm.$el.__vue__ = null &#125; // release circular reference (#6759) if (vm.$vnode) &#123; vm.$vnode.parent = null &#125; &#125;&#125; $destory清除实例里的方法 11.组件销毁完毕12.Destory函数调用生命周期函数Destory调用。 至此Vue的一段生命周期便执行完成，它完成了它的使命，暂时。 总结今天先告一段落…终于考完试了！打算下面几天都拿来肝文了！已经加入一些Vue源码片段来展示各个生命周期函数：~），我依然在完善这篇文章，部分代码尚未找到，所以后续还会有增加…","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"CSS动画构成解剖","date":"2021-03-28T14:35:29.000Z","path":"2021/03/28/解剖CSS动画/","text":"CSS动画特效的基本构成 自制定和发布以来，CSS规范便颇受世人青睐。&lt;hr style=” border:solid; width:100px; height:1px;” color=#000000 size=1”&gt; @TOC CSS动画效果特别是对于专业网页设计者来说，CSS无疑是给他们的设计者带来了新的希望······运用CSS，不仅能设计出精美的网页效果，而且还能提高网页的可访问性，可维护性，从而为网页设计节省大量的时间和精力。 ————摘自《CSS权威指南》 人类居住在一颗美丽的星球上，这是一颗飘泊于太阳系中的蓝色行星，它与太阳系中的其他几颗行星一同围绕太阳系的中心——太阳，无休无止的旋转着。 一、动画效果的构成我们知道地球约每24小时就会自转一圈，每约一年围绕太阳公转一次，那么无论是自转还是公转，完成后地球必然又会回到那时她开始自转或公转的位置。如果我们把地球看作一个巨大的、加了“border-radius:50%;”的&lt; div &gt;，那么宇宙——这团巨大的黑色迷雾是否可以看作&lt; body &gt;？可以吧。地球的转动是按照一定的轨迹进行的，她自然不会随心所欲地围着太阳乱转，地球的运动轨迹是由太空中各种力互相作用最终趋于稳定形成的，这些各种各样来自四面八方的“力属性”最终规定了这颗加了“border-radius:50%;”的巨大的&lt; div &gt;的运动轨迹——“你得从这走，到那去，还得慢一点。” 1.规定目标样式属性transfrom：当我们为某个元素添加了这么个属性后，就确定了我们要让这个“大星球”动弹动弹了，无论是让它自转还是公转，都离不开transform，它的众多属性可以支持我们能想到的各种动弹的方式，在进行一些不太正当的挪动时，还可以通过组合各种transfrom属性的组合使用来调整方位。以下是transform的部分常用属性：| 属性名 | 效果 || – | – || translateX(x) | 执行X轴向的横向移动。 || translateY(y) | 执行Y轴向的纵向移动。 || translateZ(z) | 执行Z轴向的远近移动。（在非3D条件下无效） || translate3d(x,y,z) | 以上三个translate属性的集合写法，效果相同。 || rotateX(xx) | 执行以X轴为轴心的旋转。（在非3D条件下效果仅类似缩放）|| rotateY(xx) | 执行以Y轴为轴心的旋转。（在非3D条件下效果仅类似缩放） || rotateZ(xx) | 执行以Z轴为轴心的旋转。（在非3D条件下效果仅类似缩放） || scale3d(x,y,z) | 以上三个rotate属性的集合写法，效果相同。 || scaleX(x) | 执行X轴向的横向缩放。 || scaleY(y) | 执行Y轴向的纵向缩放。 || scaleZ(z) | 执行Z轴向的3D缩放。 || scale3d(x,y,z) | 以上三个scale属性的集合写法，效果相同。 || perspective(n) | 设定3D效果的必需属性，设定显示屏距离浏览器版面（即由transform-origin设置的3D元素的参考系原点）的距离，添加到父元素上，或者在@keyframes函数里作为CSS属性和变换操作写在一起。 || transfrom-style | 默认值flat，嵌套元素在2D平面中呈现; 可赋值preserve-3d 嵌套元素在3D空间中呈现 || transfrom:none | 不执行变换 || transfrom:origin | 设置元素执行旋转、位移、缩放等操作时的原点，常见用于调整旋转元素的半径 | 这里面的perspective属性当时花的时间比较长，感觉有点难理解，多说两句也方便以后查阅：perspective属性是设定3D效果的必需属性，将浏览器平面转换为立体空间。设定显示屏距离浏览器版面的距离，相对来说为施加了3D变换的元素设定|其需要参考的坐标系|距离屏幕的远近，不添加此属性，效果中不会出现远近的概念。比如设置了perspective为200px;那么transformZ的值越接近200，与屏幕的距离便越近，看上去也就越大（近大远小嘛…），超过200就跑到头里甚至身后，自然就看不到。 二、控制运动路径上面说到给这个“border-radius:50%;”的巨型添加了动作，但是你会发现它一闪就完成了（很快啊！），地球如果如此运作，后果是不堪设想的。效果上来看也很不自然，这种不自然的感觉，源于“过程”的缺少，添加运动属性的元素在受到影响后会马上执行——这也就意味着我们马上就能看到执行完后的样子，这种速度有时候不会带来好的结果。关于对这段过程进行限速，常用的方法有两种： 过渡属性transition 动画函数调用属性animation transition先说transition属性，一种相对简单的方法，但在过程控制的精细度方面不如可以调用动画函数来控制的animation属性，在书写的时候我们可以单写一个transition属性，然后在它后面隔一个空格仅写一个子属性的值（就像写border时那样）；也可以把它的子属性一个个罗列出来分别为他们写值，我先列出transition的四个子属性：| 子属性 | 控制目标 ||–|–|| transition-property | 要添加过渡效果的 CSS 属性 的名称（比如width\\background-color） || transition-duration | 规定完成过渡效果需要的秒数或毫秒数。 || transition-timing-function | 规定速度效果的速度曲线。 || transition-delay | 定义过渡效果开始前的延时。 | 子属性 可用值 transition-property all 或 众多CSS属性 transition-duration 时间（秒或毫秒） transition-timing-function 匀速linear、快到慢ease、持续加速ease-in、减速至停ease-out、先加速后减速ease-in-out、自定义贝塞尔曲线cubic-bezier(n,n,n,n)、分步完成，每步瞬间完成steps transition-delay 时间（秒或毫秒，负值当即开始）或 initial 或 inherit transition支持同时制定多个目标的过渡效果，但各目标的效果之间需要使用英文逗号隔开，比如： 1234567.container:hover &#123; cursor: pointer; transform: rotate(0deg) scale(1) translateY(10px); transition: background 1s linear 2s,border-radius 2s ease-in 3s; //此条中，英文逗号隔开了两个CSS属性的变化 z-index: 400;&#125; animation接下来是animation属性，这一属性支持在值中写动画函数的名字以完成对动画函数的调用，动画函数的存在使其对动画过程的控制更加的精确。与transition相同的一点是你也可以选择分写子属性或者直接写一个animation属性然后罗列各个子属性的值，我们先来看一下animation的子属性都有哪些：|子属性| 作用 ||–|–|| animation-name | 规定需要调用的keyframes动画函数的名称。 || animation-duration | 规定动画持续的总时间。 || animation-timing-function | 规定动画效果的速度曲线。 || animation-delay | 设定动画开始前的延时。 || animation-iteration-count | 设定动画需要播放的次数。 || animation-direction | 设定是否需要反向和循环播放动画。 | 子属性 可用值 animation-name 已有的keyframes动画函数名 animation-duration 时间（秒或毫秒） animation-timing-function 匀速linear、快到慢ease、持续加速ease-in、减速至停ease-out、先加速后减速ease-in-out、自定义贝塞尔曲线cubic-bezier(n,n,n,n)、分步完成，每步瞬间完成steps animation-delay 时间（秒或毫秒，负值当即开始）或 initial 或 inherit animation-iteration-count 次数（数字） animation-direction 布尔值（true 或 false） @keyframes上面说到了“动画函数”一词，我这样说仅仅是为了便于理解，这种“动画函数”其实是由“@keyframes” 进行创建的一种通过控制关键帧（keyframes）来达到控制动画过程这一目的的一种规则（但是它真的很像一种函数不是吗…），不管那么多了，下面来介绍一下“@keyframes”规则的写法： 123456789@keyframes 动画名称 &#123; from &#123; CSS属性: CSS值 或 CSS属性:子属性(子属性值); &#125; to &#123; CSS属性: CSS值 或 CSS属性:子属性(子属性值); &#125;&#125; 您大可把关键帧界定的更加细致，就像这样： 123456789@keyframes 动画名称 &#123; 50% &#123; CSS属性: CSS值 或 CSS属性:子属性(子属性值); &#125; 100% &#123; CSS属性: CSS值 或 CSS属性:子属性(子属性值); &#125;&#125; 甚至这样： 123456789101112131415161718@keyframes 动画名称 &#123; 0% &#123; CSS属性: CSS值 或 CSS属性:子属性(子属性值); &#125; 50% &#123; CSS属性: CSS值 或 CSS属性:子属性(子属性值); &#125; 70% &#123; CSS属性: CSS值 或 CSS属性:子属性(子属性值); &#125; 80% &#123; CSS属性: CSS值 或 CSS属性:子属性(子属性值); &#125; 100% &#123; CSS属性: CSS值 或 CSS属性:子属性(子属性值); &#125; &#125; 三.基本构成起始状态、目标状态 + 过程 = 完整动画四、依据路径执行动画最后一步就是生成您的动画了，依据CSS动画的基本构成原理，把控制元素目标状态的动作属性和控制过程的关键帧规定结合起来，也就是在transition属性里规定过渡效果或者在animation属性里调用您规定的关键帧@keyframes规则。下面是一个实例，关于在animation属性里调用@keyframes关键帧规则名： 123456789101112131415161718192021.row1 div &#123; animation: keyname 15s linear infinite; //关键帧函数名keyname&#125;.row2 div &#123; animation: keyname 20s linear infinite;&#125;.row3 div &#123; animation: keyname 40s linear infinite;&#125;@keyframes keyname &#123; from &#123; transform: translateX(500px); &#125; to &#123; transform: translateX(-100px); &#125;&#125; 总结这次总结了一些比较基础的CSS特效的构成模式，当然并不是所有的CSS特效都是这样的构造，如果您对这方面感兴趣的话，还是要去更多的搜集资料和各种属性、写法，但上面介绍的这些，通过与CSS和JS的结合，已经能构建出比较可观的特效，以下便是基于上述知识构建出的纯CSS特效。如果这篇文章帮到了您，我很荣幸，也期待您的指点：· ）","tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"let、const与块级作用域","date":"2021-03-08T13:52:46.000Z","path":"2021/03/08/let、const与块级作用域/","text":"let、const块级声明与块级作用域绑定","tags":[{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"}]},{"title":"XMLHttpRequest对象解读&AJAX使用","date":"2021-02-25T14:38:00.000Z","path":"2021/02/25/XMLHttpRequest对象解读&AJAX使用/","text":"AJAX技术","tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/tags/AJAX/"}]},{"title":"浏览器缓存机制","date":"2021-02-24T18:09:52.000Z","path":"2021/02/25/浏览器缓存机制/","text":"Http的Cache机制由四个部分组成，Last-Modified（If-Modified-Since）、Etag（If-None-Match）、Cache-Control、Expires ，我会在下文更详细说明它们在Cache机制中的作用。","tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"JavaScript正则表达式（1）","date":"2021-02-23T19:51:51.000Z","path":"2021/02/24/JavaScript正则表达式（1）/","text":"正则表达式","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"Vue-cli4.x 中的全局样式配置","date":"2021-02-23T19:51:51.000Z","path":"2021/02/24/Vue-cli 4.x 中的全局样式配置/","text":"在Vue-cli 4.x 中配置样式 一、插件准备你需要安装3个插件: dart-sass &amp; sass-resources-loader &amp; sass-loader安装dart-sass &amp; sassresource-loader 1234npm install sass sass-loader -D//这个指令会安装dart-sass和sass-loader;//node-sass安装中经常出现各种问题;//性能也比不上dart-sass,在2020年末被替代; 安装sass-resources-loader 12npm i sass-resources-loader -D//ver2.2.2,当前的最新版; 我的配置信息: 二、开始配置1.vue.config.js配置你可能已经发现在vue-cli4.x创建的项目中不再有config和dist了,对,所有的配置我们都要在vue.config.js中完成.那么,在项目目录下直接创建vue.config.js,然后进入下一步. 12345678910111213module.exports = &#123; publicPath: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;&#x27; : &#x27;/&#x27;, outputDir: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;dist&#x27; : &#x27;devDist&#x27;, lintOnSave: false, css: &#123; loaderOptions: &#123; scss: &#123; AdditionalData: `@import &quot;./src/style/main.scss&quot;;` /*ver8.x改为prependData: `@import &quot;./src/style/main.scss&quot;;`,运行时请去掉本注释 */ &#125; &#125; &#125;&#125; 因为我们现在只配置全局scss需要的配置,那…..我就只写这一部分需要的配置了,如果想一步到位的话CSDN搜索vue-cli4 vue.config.js配置即可. .App.vue配置很简单的一步,在App.vue的&lt; style &gt;标签中加入lang属性: 1&lt;style lang=&quot;scss&quot;&gt; 即可. 好吧,我们在全局scss文件里随便写点什么: 1234body &#123; background-color: rgb(177, 60, 82);&#125; 到此说明我们的全局scss文件引入成功了.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"JavaScript数据类型","date":"2021-02-06T17:29:42.000Z","path":"2021/02/07/JavaScript数据类型/","text":"JavaScript数据类型","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JS复杂条件下的预解析","date":"2020-12-06T15:14:40.000Z","path":"2020/12/06/JS复杂条件预解析/","text":"JavaScript预解析","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JS预解析机制","date":"2020-12-06T15:14:40.000Z","path":"2020/12/06/JavaScript预解析机制/","text":"JavaScript预解析","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"CSS的三大特性","date":"2020-11-27T02:30:56.000Z","path":"2020/11/27/CSS的三大特性/","text":"CSS的三大特性 下面我会依次阐述这三种特性使用时的注意事项与方法。 一、CSS层叠性在对一个元素所设置的多个不同选择器 或者 一个选择器内，对同一样式不同的值，会造成样式冲突，此时需要考虑CSS的层叠性，CSS将根据层叠特性来决定使用哪种样式。 特性简述：当出现上述情况时，CSS将会采用距离目标元素的代码最近的样式，就近原则。如下所示： 123456&lt;style&gt; div &#123; background-color: yellow; background-color: skyblue; &#125;&lt;/style&gt; 1234&lt;body&gt; &lt;div&gt;示例：CSS层叠性&lt;/div&gt;&lt;/body&gt; 依据上述，以上代码显示出盒子的颜色应当为天蓝色。以下为另一种情况： 12345678&lt;style&gt; div &#123; background-color: skyblue; &#125; div &#123; background-color: yellow; &#125;&lt;/style&gt; 这段代码的运行结果为黄色，下方控制黄色的选择器距离目标元素更近。 二、CSS继承性在对子级标签的样式进行设置时需要注意，其会继承其父标签中部分能被其自身继承的样式，而且“继承父元素样式”被使用的优先级低于“使用该元素被直接设定的样式”，恰当的利用这一特性可以缩减代码量，例如对多个同父子元素内字体与背景色的设置，就可以直接为其父元素设置样式，使所有子标签样式相同。 1234567891011&lt;style&gt; div &#123; color: skyblue; font-size: 15px; &#125; #继承性2 &#123; color: yellow; font-size: 30px; &#125;&lt;/style&gt; 12345678&lt;body&gt; &lt;div&gt; &lt;p&gt;示例：CSS继承性1&lt;/p&gt; &lt;p id=&quot;继承性2&quot;&gt;示例：CSS继承性2&lt;/p&gt; &lt;p&gt;示例：CSS继承性3&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 这段代码运行后，显示效果如下可以看到的是子级元素继承了父级元素的样式，但出现针对自己的样式时依然会优先使用自己专属的样式（跟能叫外卖就不会去食堂吃大锅菜是一样的）。 三、CSS优先级前面在说到CSS选择器的时候我说到了CSS的权重、优先级相关，这里也算是对那节内容的补充吧。在选择器相同的时候将需要考虑我们前面说的“层叠性”特性，而当选择器不同时，将需要考虑CSS的“优先级“特性。“选择器权重”这一概念是被“优先级”这一概念包含在内的。|选择器|选择器权重 ||–|–|| 继承或 *全选 | 0，0，0，0||元素选择器|0，0，0，1 ||类选择器、伪类选择器|0，0，1，0|ID选择器|0，1，0，0|| 继承或 *全选 | 0，0，0，0||行内样式style=” “|1，0，0，0 ||!important 重要|无穷大| 这些权重值基本可以看作数学数值个十百千，理所当然的是占位越高权重越大，在多个可选的选择器内，权重大的选择器将会被优先采用，而若是在样式后跟上!important，则选择器必定被采用，因其权重为“无限大”。下面请看一个示例： 123456789101112131415&lt;style&gt; div &#123; color: grey; font-size: 15px; &#125; #优先级 &#123; color: yellow; font-size: 30px; &#125; .示例 &#123; background-color: skyblue; &#125;&lt;/style&gt; 123&lt;body&gt; &lt;div class=&quot;示例&quot; id=&quot;优先级&quot;&gt;示例：优先级&lt;/div&gt;&lt;/body&gt; 若是按照“层叠性”的就近原则，此处应当采用class=”示例”设置的样式，但此处的选择器众多，应当参照“优先级”特性而非“层叠性”特性；ID选择器因为在所示三种选择器中为权重最高(0,1,0,0)的一种，所以即便在中间放置也依然被优先采用了。看下!important的用法： 123456789101112&lt;style&gt; div &#123; color: grey!important; font-size: 30px; &#125; #优先级 &#123; color: yellow; font-size: 50px; &#125;&lt;/style&gt; 123&lt;body&gt; &lt;div class=&quot;示例&quot; id=&quot;优先级&quot;&gt;示例：优先级&lt;/div&gt;&lt;/body&gt; 还是刚才的HTML代码，这次我为标签选择器中的颜色样式添加了!important，那么是否整个标签选择器的样式都会被采用？并没有，标签选择器中的颜色样式因为加大权重被使用，而标签选择器中的其他属性（比如设置的字号）并不能被采用，!important仅能加强某个样式属性的权重，并不能加强整个选择器的权重。 总结 以上便是CSS三大特性的相关，在下独自整理，可能并不全面，如果有帮助到您，在下荣幸之至，如果您发现了我的错误与缺陷，在下恳请您的指点，多谢！","tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"CSS選擇器的种类&使用","date":"2020-11-21T16:17:55.000Z","path":"2020/11/22/CSS選擇器的种类&使用/","text":"CSS选择器的种类&amp;使用","tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"CSS中position定位属性的使用","date":"2020-11-19T15:02:24.000Z","path":"2020/11/19/CSS中Position定位属性的使用/","text":"CSS中定位属性的使用","tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]}]