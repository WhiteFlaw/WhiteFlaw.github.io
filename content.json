{"meta":{"title":"白瑕的外星殖民所","subtitle":"","description":"","author":"白瑕","url":"http://example.com","root":"/"},"pages":[{"title":"文章分类","date":"2018-06-11T02:13:21.000Z","updated":"2021-01-14T06:33:45.447Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"page新建页面1","slug":"page新建页面1/page新建页面1","date":"2021-01-14T09:04:21.000Z","updated":"2021-01-14T09:04:21.312Z","comments":true,"path":"2021/01/14/page新建页面1/page新建页面1/","link":"","permalink":"http://example.com/2021/01/14/page%E6%96%B0%E5%BB%BA%E9%A1%B5%E9%9D%A21/page%E6%96%B0%E5%BB%BA%E9%A1%B5%E9%9D%A21/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"歡迎來到白瑕的個人博客！","slug":"歡迎！","date":"2021-01-14T04:57:35.034Z","updated":"2021-01-14T09:37:29.598Z","comments":true,"path":"2021/01/14/歡迎！/","link":"","permalink":"http://example.com/2021/01/14/%E6%AD%A1%E8%BF%8E%EF%BC%81/","excerpt":"","text":"Hi！歡迎來到白瑕的個人博客，你可以在下面挑些自己感興趣的内容看，或是在評論區吐槽幾句！如果使用過程中遇到了意料之外的麻煩，請通過左邊頭像下的方式告訴他，他正等著你的意見！","categories":[],"tags":[]},{"title":"JS预解析机制","slug":"JS预解析机制","date":"2020-12-06T15:14:40.000Z","updated":"2021-01-14T09:49:09.905Z","comments":true,"path":"2020/12/06/JS预解析机制/","link":"","permalink":"http://example.com/2020/12/06/JS%E9%A2%84%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6/","excerpt":"JavaScript预解析","text":"JavaScript预解析 @TOC JS预解析？浏览器中的JS解析器运行JavaScript的过程为先进行 预解析 之后再进行 代码执行。主要为JS执行机制的问题。 一、预解析受体预解析会把JS代码中的所有var和function提升至其所在作用域的最上方(内部的最上方），以进行优先的声明/定义。告诉全局作用域某某变量被声明出来了，并在内存中提前开辟空间。受体： var 、 function 二、对var的预解析对var的预解析不提升|赋值|操作，只提升|声明变量|部分的代码，提升完毕后对声明变量部分进行预解析，全局作用域中加入了这个变量的信息，之后代码依然遵循由上到下的顺序来进行执行。下面举个例子： 12345&lt;script&gt; var div = document.querySelectorAll(&#x27;div&#x27;) var up = document.querySelector(&#x27;up&#x27;); var down = document.querySelector(&#x27;down&#x27;);&lt;/script&gt; 人类与机器解析方式的不同也将导致他们看到的代码不同，上方代码在解析器看来应当是以下： 12345678&lt;script&gt; var div var up var down div = document.querySelectorAll(&#x27;div&#x27;) up = document.querySelector(&#x27;up&#x27;); down = document.querySelector(&#x27;down&#x27;);&lt;/script&gt; 只提升了声明部分而没有提升赋值部分。 三、对function的预解析对function的预解析不提升|函数体|部分，只提升|声明函数|部分的代码，因此也没必要写括号了，提升完毕后对声明函数部分进行预解析，全局作用域中加入了这个函数的信息，之后代码依然遵循由上到下的顺序来进行执行此函数。下面举个例子： 123456 &lt;script&gt;demo()var demo = function() &#123; console.log(12);&#125;&lt;/script&gt; 以上代码在进行解析时可以看作以下格式： 1234567&lt;script&gt;var demo;demo = function() &#123; console.log(12);&#125;demo(); &lt;/script&gt; 四、var在作用域内在一些比较常规的作用域内声明变量时使用了var，那么声明出来的变量可以在全局范围内使用，但是也有不行的时候，以下我各举一个例子： 12345678910&lt;script&gt; for (var i = 0; i &lt; 10; i++) &#123; console.log(i) &#125; function fn(i) &#123; console.log(i) &#125; fn(i)&lt;/script&gt; 在这个例子中，for循环里的var是全局变量，下面的函数会输出“10”。但接下来这个： 123456789&lt;script&gt;function fn1() &#123; for(var i=0;i&lt;5;i++)&#123; &#125; console.log(i)//5&#125;fn1()console.log(i)//i is not defined&lt;/script&gt; var也在另一个函数function fn1内，变量就成为了这个函数作用域中的变量，只能提升至这个函数作用域的顶部。 五、function作参、在事件处理程序内函数在使用时会有作为参数、被包含于侦听器等等诸多情况，我们首先应该从“这部分函数所处的作用域”着手。我们看下面这段代码： 12345678910&lt;script&gt; div.addEventListener(&#x27;mousemove&#x27;, function (e) &#123; e = event || window.event; var x = e.pageX; var y = e.pageY; console.log(&#x27;当前坐标：（&#x27; + x + &#x27;,&#x27; + y + &#x27;)&#x27;); pic.style.left = x - 50 + &#x27;px&#x27;; pic.style.top = y - 25 + &#x27;px&#x27;; &#125;);&lt;/script&gt; 预解析时相当于以下(”var ???”这一步并不存在，为了能表达将内部函数提升并且能顺利调用才加上）： 123456789101112var ??? = function ???(e)??? = function (e) &#123; e = event || window.event; var x = e.pageX; var y = e.pageY; console.log(&#x27;当前坐标：（&#x27; + x + &#x27;,&#x27; + y + &#x27;)&#x27;); pic.style.left = x - 50 + &#x27;px&#x27;; pic.style.top = y - 25 + &#x27;px&#x27;; &#125; div.addEventListener(&#x27;mousemove&#x27;, ???) 传参过程中，参数是函数的类型传入了侦听器内。 传参的作用域面向全局，传参的作用域在全局作用域，所以|传入侦听器作为参数的函数|若是进行提升应当在其所在的作用域——全局作用域 中进行提升，上面最近的例子，函数直接进入全局作用域进行提升。函数体不动。 以上是我对于JS预解析的一些见解与猜想。若是您发现了错误的观点，可以通过私信联系我，不胜感激。","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"CSS的三大特性","slug":"CSS的三大特性","date":"2020-11-27T02:30:56.000Z","updated":"2021-01-14T10:09:00.733Z","comments":true,"path":"2020/11/27/CSS的三大特性/","link":"","permalink":"http://example.com/2020/11/27/CSS%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/","excerpt":"CSS的三大特性","text":"CSS的三大特性 下面我会依次阐述这三种特性使用时的注意事项与方法。 一、CSS层叠性在对一个元素所设置的多个不同选择器 或者 一个选择器内，对同一样式不同的值，会造成样式冲突，此时需要考虑CSS的层叠性，CSS将根据层叠特性来决定使用哪种样式。 特性简述：当出现上述情况时，CSS将会采用距离目标元素的代码最近的样式，就近原则。如下所示： 123456&lt;style&gt; div &#123; background-color: yellow; background-color: skyblue; &#125;&lt;/style&gt; 1234&lt;body&gt; &lt;div&gt;示例：CSS层叠性&lt;/div&gt;&lt;/body&gt; 依据上述，以上代码显示出盒子的颜色应当为天蓝色。以下为另一种情况： 12345678&lt;style&gt; div &#123; background-color: skyblue; &#125; div &#123; background-color: yellow; &#125;&lt;/style&gt; 这段代码的运行结果为黄色，下方控制黄色的选择器距离目标元素更近。 二、CSS继承性在对子级标签的样式进行设置时需要注意，其会继承其父标签中部分能被其自身继承的样式，而且“继承父元素样式”被使用的优先级低于“使用该元素被直接设定的样式”，恰当的利用这一特性可以缩减代码量，例如对多个同父子元素内字体与背景色的设置，就可以直接为其父元素设置样式，使所有子标签样式相同。 1234567891011&lt;style&gt; div &#123; color: skyblue; font-size: 15px; &#125; #继承性2 &#123; color: yellow; font-size: 30px; &#125;&lt;/style&gt; 12345678&lt;body&gt; &lt;div&gt; &lt;p&gt;示例：CSS继承性1&lt;/p&gt; &lt;p id=&quot;继承性2&quot;&gt;示例：CSS继承性2&lt;/p&gt; &lt;p&gt;示例：CSS继承性3&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 这段代码运行后，显示效果如下可以看到的是子级元素继承了父级元素的样式，但出现针对自己的样式时依然会优先使用自己专属的样式（跟能叫外卖就不会去食堂吃大锅菜是一样的）。 三、CSS优先级前面在说到CSS选择器的时候我说到了CSS的权重、优先级相关，这里也算是对那节内容的补充吧。在选择器相同的时候将需要考虑我们前面说的“层叠性”特性，而当选择器不同时，将需要考虑CSS的“优先级“特性。“选择器权重”这一概念是被“优先级”这一概念包含在内的。|选择器|选择器权重 ||–|–|| 继承或 *全选 | 0，0，0，0||元素选择器|0，0，0，1 ||类选择器、伪类选择器|0，0，1，0|ID选择器|0，1，0，0|| 继承或 *全选 | 0，0，0，0||行内样式style=” “|1，0，0，0 ||!important 重要|无穷大| 这些权重值基本可以看作数学数值个十百千，理所当然的是占位越高权重越大，在多个可选的选择器内，权重大的选择器将会被优先采用，而若是在样式后跟上!important，则选择器必定被采用，因其权重为“无限大”。下面请看一个示例： 123456789101112131415&lt;style&gt; div &#123; color: grey; font-size: 15px; &#125; #优先级 &#123; color: yellow; font-size: 30px; &#125; .示例 &#123; background-color: skyblue; &#125;&lt;/style&gt; 123&lt;body&gt; &lt;div class=&quot;示例&quot; id=&quot;优先级&quot;&gt;示例：优先级&lt;/div&gt;&lt;/body&gt; 若是按照“层叠性”的就近原则，此处应当采用class=”示例”设置的样式，但此处的选择器众多，应当参照“优先级”特性而非“层叠性”特性；ID选择器因为在所示三种选择器中为权重最高(0,1,0,0)的一种，所以即便在中间放置也依然被优先采用了。看下!important的用法： 123456789101112&lt;style&gt; div &#123; color: grey!important; font-size: 30px; &#125; #优先级 &#123; color: yellow; font-size: 50px; &#125;&lt;/style&gt; 123&lt;body&gt; &lt;div class=&quot;示例&quot; id=&quot;优先级&quot;&gt;示例：优先级&lt;/div&gt;&lt;/body&gt; 还是刚才的HTML代码，这次我为标签选择器中的颜色样式添加了!important，那么是否整个标签选择器的样式都会被采用？并没有，标签选择器中的颜色样式因为加大权重被使用，而标签选择器中的其他属性（比如设置的字号）并不能被采用，!important仅能加强某个样式属性的权重，并不能加强整个选择器的权重。 总结 以上便是CSS三大特性的相关，在下独自整理，可能并不全面，如果有帮助到您，在下荣幸之至，如果您发现了我的错误与缺陷，在下恳请您的指点，多谢！","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"CSS選擇器的种类&使用","slug":"CSS选择器的种类&使用","date":"2020-11-21T16:17:55.000Z","updated":"2021-01-14T10:11:48.944Z","comments":true,"path":"2020/11/22/CSS选择器的种类&使用/","link":"","permalink":"http://example.com/2020/11/22/CSS%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E7%A7%8D%E7%B1%BB&%E4%BD%BF%E7%94%A8/","excerpt":"CSS选择器的种类&amp;使用","text":"CSS选择器的种类&amp;使用 @TOC","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"CSS中position定位属性的使用","slug":"CSS中Position定位属性的使用","date":"2020-11-19T15:02:24.000Z","updated":"2021-01-14T09:41:30.234Z","comments":true,"path":"2020/11/19/CSS中Position定位属性的使用/","link":"","permalink":"http://example.com/2020/11/19/CSS%E4%B8%ADPosition%E5%AE%9A%E4%BD%8D%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"CSS中定位属性的使用","text":"CSS中定位属性的使用 CSS中定位属性的使用网页元素默认占用文档流，插入或生成元素后，其将默认按照从左到右的顺序依次排列，这将导致页面中的各种元素因空间占用问题难以被设计至目标效果。若将整个页面看做一个二层透明，底层白色的双层结构的俯视，那我们可以简单的理解为『大部分元素默认占用底层空间』，但是各种元素共一层，每个个体都占有一部分空间，那么将导致我们无法把操作的元素放置到俯视视角的目标位置。为了摆脱底层的空间占用限制，有效利用二层空间帮我们达到目标效果，可以使用CSS中的定位属性，添加了定位属性的元素将拥有”浮动”效果，会脱离文档流（可简单理解为脱离上面说的白色底层)，进入漂浮状态，即可以使用”二层空间”，可达到这样漂浮效果的还有display:float、z-index等，本篇主要讲position属性（定位属性）。position属性用于为目标元素确定位置（确定漂浮态位置），其后可以跟从6种定位方法（其中position:static、position:relative无法使目标元素脱离文档流): position:static position:fixed position:relative position:absolute position:inherit position:sticky 接下来依次阐述 position:static定位属性的默认值，即『无定位』，目标元素将依然存在于正常文档流中，使用此种定位与不对目标元素施加定位将会是同种效果，对受static影响的元素设置right,bottom,top,left将无效，同样的其他元素若相对受static影响的元素设置left,bottom,right,top也将无效。对其设置margin和padding有效。 position:fixed这种定位方法被称为“固定定位”，这种方法以浏览器边框作为参照，注意这里的 参照 不受浏览器边框尺寸变化影响，其以可视窗口作为参照物，改变浏览器可视窗口显示尺寸后目标元素与浏览器边框的距离不会改变，如此定位的元素也不受上下左右滚动条的影响，其会随着底层和漂浮层移动，与其保持相对静止，常看到跟随屏幕滚动的“回到顶部”就是利用JS和该定位制作。可以使目标元素脱离文档流进入漂浮状态。后面添加left,right,top,bottom来对位置进行调整,浏览器的坐标系坐标原点在左上角，依据此来进行调整（建议用截图工具测量） 1234567&lt;style&gt; .固定定位 &#123; position: fixed; top: 10px; left: 10px; &#125;&lt;/style&gt; position:relative这种定位方法被称为“相对定位”，所谓“相对”既是相对定位前其在正常文档流中的位置（的左上角为坐标原点）进行定位，移动受relative影响的元素时这个元素原本所占的空间依然在原处不改变，可以对其设置right,left,top,bottom进行目标元素位置的调整。另外受这种定位影响的元素可以被受position：absolute影响的元素选中为“包含者”来作为自身absolute定位的参照物，absolute会以就近原则选择距离自己最近的受定位的父元素作参照，这个特点便是“子绝父相”（这种叫法并不严谨），在编写时可以父元素使用相对定位，子元素使用绝对定位，避免调整元素时导致其他元素错位。 position：absolute这种方法被称为“绝对定位”，会选取与受定位元素辈分最近的、已经 受到定位的、父级元素 进行定位，前提是这个父级元素受到的定位不是position:static。跟从上方所说，这种定位方法设置了“子绝父相”结构的组成部分——子元素部分 的位置，利用“受到absolute定位的元素会选取距离自己最近的受到定位的父元素进行定位”的特点，可以将受到absolute影响的元素放入受到relative定位的元素中作为其子元素，这样在后面调整某个模块时仅调节relative定位的父元素即可让整个模块完好的移动。 123456789101112131415161718192021 &lt;style&gt; .父级元素 &#123; position: relative; top: 10px; left: 10px; &#125; .子级元素 &#123; position: absolute; top: 10px; left: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;父级元素&quot;&gt; &lt;span class=&quot;子级元素&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; position:inherit我一直觉得这种定位方法很特殊……inherit也可以作为其他属性的值来使用，这里我只说它跟在position后时的情况，“inherit”这个单词的意思为“继承”，它在定位中的用途也一如它的汉意：受inherit影响的元素将会使用与其父元素相同的定位方式，注意是仅继承定位方式，而不一定会以父元素作为参照来定位。可以对其设置right,bottom,left,top来进行定位，具体定位规则依据继承来的不同的定位而不同。因为其与上级元素两元素间有父子关系，所以被称作 定位：继承； 1234567891011121314&lt;style&gt; .父级元素 &#123; position: fixed; top: 20px; right: 30px; &#125; .子级元素 &#123; position: inherit; /*此处子级元素继承父级元素，定位方式为fixed固定定位*/ top: 100px; right: 150px; &#125;&lt;/style&gt; position:sticky这种方法被称为“粘性定位”，受粘性定位的元素依据页面滚动，在position:relative与position:fixed两定位方法之间进行切换。在页面的滚动不超出目标区域时，它的表现更加偏向position:relative; 而当页面滚动超出目标区域时，它的表现更加偏向position:fixed它会将目标元素固定在目标位置。其定位表现是：在跨越特定阈值前为相对定位的定位方法，超过阈值之后为固定定位的定位方法（可以拿这个来做“回到顶部”）。这个特定阈值指的是 top, right, bottom 或 left 之一，也就是仅指定 top, right, bottom 或 left 四个阈值之一，才可使粘性定位生效，否则其行为与相对定位相同。 1234567&lt;style&gt; div.sticky &#123; position: -webkit-sticky; /*仅Safari需要加入此条*/ position: sticky; top: 10px; &#125;&lt;/style&gt; 在对页面上的元素进行设计时，优先设置主体（页面主体）元素作为页面中心，以其作为原点进行其他元素的定位，可以防止中途定位某个元素时其他元素跟着动的尴尬情况，减少不必要的工作量，方便后期修改。 以上是我据本阶段的学习得出的一些经验与心得，如果对您起到帮助，在下十分荣幸；若是您发现了我的不足，恳请您的指点！","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"CSS","slug":"前端/CSS","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]}