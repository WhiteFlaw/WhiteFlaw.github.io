[{"title":"欢迎你来到这里~","date":"2021-10-31T00:39:30.000Z","path":"2021/10/31/20211031/","text":"v1.1.8概覽: 这次更新了5篇文章 《学习JavaScript数据结构与算法》第三章 数组 《学习JavaScript数据结构与算法》第四章 栈 crbug1173575 non JS module files deprecated 用原生NodeJS封装一个服务器 新增了&quot;数据结构与算法&quot;专栏来存放那些算法笔记，希望你会喜欢它们； 我开始学Node.js了， 我一直希望能够掌握一门写后端的手艺（因为我不能说Node是一门语言，所以...en）。 祝你们过得愉快。","tags":[]},{"title":"用原生NodeJS封装一个服务器","date":"2021-10-30T06:30:09.000Z","path":"2021/10/30/用原生NodeJS封装一个服务器/","text":"前言目的是实现form.ejs页面的数据能被接收并呈现,然后URL改变时页面能够正常跳转URL中有扩展名的时候交给静态web解决, 没有扩展名交给路由解决routes.js模块中封装了static()方法来确保文档类型正确, 顺便做静态web.app.js模块负责服务器和路由;views目录中存放所有页面 先解决routes.js吧,到时候我们直接把它的方法调到app.js中用就好了. 二、app.js我们的服务器建立在此处, 获取到用户在客户端发送的请求信息req和相应res,利用这两个参数, 我们就可以判定他到了哪个页面, 现在该发点甚麽给他那边来生成页面; 引入模块我们需要使用这些模块中的方法; 1234const http = require(&#x27;http&#x27;);const path = require(&#x27;path&#x27;);const routes = require(&#x27;./module/routes&#x27;);const ejs = require(&#x27;ejs&#x27;); 主体1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071http.createServer(function (req, res) &#123; routes.static(req, res, &#x27;static&#x27;); //向routes模块的static方法传参req, res, 静态路径static //这个静态路径应该就是集中存放网页文件的文件夹,比如wwwroot这种. const &#123; url &#125; = req; const &#123; host &#125; = req.headers; const myURL = new URL(url, `http://$&#123;host&#125;`); //拿到截止到port的,这次请求URL,比如http://127.0.0.1:3000; //并且交付new URL进行解析; let pathname = myURL.pathname; //拿到解析结果里的pathname,文件路径终点; let extname = path.extname(pathname); //path模块方法!!尝试!!拿到文件后缀名 console.log(req.method); //打印本次触发的方式, GET主要用于客户端获取数据; //POST主要用于客户端向服务端发送数据 if (!extname) &#123; //这块就是路由了,用于处理不带扩展名的URL; //检测后缀名不存在为是,执行后续操作: if (pathname == &#x27;/news&#x27;) &#123; //检测路径终点是否为/new页面 const &#123; url &#125; = req; const &#123; host &#125; = req.headers; const myURL = new URL(url, `http://$&#123;host&#125;`); //如果是news的话再次拿取截止到port的URL并解析; let searchParams = myURL.searchParams; //拿取解析结果中的searchParams属性赋值给searchParams; //这里拿哪个属性随意,就是证明一下能拿到,输出一下. console.log(searchParams); res.writeHead(200, &#123;&#x27;Content-Type&#x27;:&#x27;text/html;charset=&quot;utf-8&quot;&#x27;&#125;); //news页面文件是个html文件,这个我们就不用实时检测文件类型了; res.end(searchParams); //end()将searchParams写到页面上; &#125; else if (pathname == &#x27;/login&#x27;) &#123; //如果pathname得到的路径终点指向login页面,执行如下: ejs.renderFile(&#x27;./views/form.ejs&#x27;, &#123;&#125;, (err, data) =&gt; &#123; //ejs方法renderFile()将目标路径文件的内容渲染; //完成后执行一次在该页面的回调; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); //login也是个html文件, 同样直接界定文件类型为text/html; res.end(data); //回调函数将渲染后的页面内容end()到页面上; &#125;) &#125; else if (pathname == &#x27;/doLogin&#x27;) &#123; //又或者path指向的路径终点为doLogin(这个页面是在login页点击提交才会到的) let postData = &#x27;&#x27;; //声明postData为空; req.on(&#x27;data&#x27;, (chunk) =&gt; &#123; //在req上监听,post传输数据是以流的形式,使用on监听data事件,数据存储在chunk中 //当流将数据移交给消费者时，会触发&#x27;data&#x27;事件 postData += chunk; &#125;) req.on(&#x27;end&#x27;, () =&gt; &#123; //流中没有更多数据可供消费时，触发&#x27;end&#x27;事件 console.log(postData); res.end(postData); //end()将存储着数据的postData呈现到页面; &#125;) &#125; else &#123; //全都不是直接404, 鬼知道他怎么跑到这个地方来的 res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&quot;页面扔下你走了...&quot;); &#125; &#125;&#125;).listen(3000);//在3000端口监听; 总结就是记录个流程, 更好的方法当然是有的.","tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://example.com/tags/Node-js/"}]},{"title":"crbug/1173575, non-JS module files deprecated.","date":"2021-10-23T07:14:36.000Z","path":"2021/10/23/crbug1173575 non JS module files deprecated/","text":"","tags":[{"name":"Bug","slug":"Bug","permalink":"http://example.com/tags/Bug/"}]},{"title":"《JavaScript数据结构与算法》第四章 栈","date":"2021-10-22T03:08:53.000Z","path":"2021/10/22/《学习JavaScript数据结构与算法》第四章 栈/","text":"前言食用方法:请着重看下创建数组栈的步骤, 由于创建方便, 下半篇的例子大都基于数组型栈来说明.三四章看不懂请回来看第二章请至少在看完前三章后再去看第五章… 上一篇：第三章 14000字笔记 二、构建两种栈的大致步骤书上讲述了两种栈的创建方式，两者之间存在大量的相似之处。 都要先声明一个Stack类: 12345class Stack &#123; constructor() &#123; //constructor方法内有不同 &#125;&#125; 都要定义一系列方法来预备对栈进行的操作(如存入和取出),但针对数组和对象构建的栈, 定义的方法自然不能相同; 在使用之前都要初始化Stack类: 1const 自定义名 = new Stack(); 四、创建基于对象的栈与创建数组型栈的步骤很相似, 不做细说了.即便十分方便, 用数组来创建栈依然存在诸多缺点, 若用n代表数组的长度，大部分方法访问数组时的时间复杂度是O(n), 这个公式的意思是我们需要迭代数组直到找到目标元素，甚至需要迭代整个数组。此外,数组有序化的存储方式会占用更多的内存空间。 创建class Stack123456 class Stack &#123; constructor() &#123; this.count = 0; this.items = &#123;&#125;//需要一种数据结构来存储栈中的元素, 这里选择了数组items. &#125; 定义用于操作栈的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Stack &#123; constructor() &#123; this.count = 0; this.items = &#123;&#125; &#125; push(element) &#123; this.items[this.count] = element; this.count++; &#125; pop(element) &#123; if (this.isEmpty()) &#123; return undefined; &#125; this.count--; const result = this.items[this.count]; //将被删除的元素赋值给result; delete this.items[this.count]; //delete操作符用于删除对象中的某个属性; return result; //返回被删除的元素; &#125; peek(element) &#123; if (this.isEmpty()) &#123; return undefined; &#125; return this.items[this.count - 1]; //length-1取到栈顶值; &#125; isEmpty(element) &#123; return this.count === 0; &#125; size() &#123; return this.count; &#125; toString () &#123; //对象型栈无法使用toString数组方法,需要自定义方法来对栈内容进行打印; if(this.isEmpty()) &#123; return &#x27;&#x27;; &#125; let objString = `$&#123;this.items[0]&#125;`; //使用最底部字符串作为初始值 for(let i = 1; i &lt; this.count; i++) &#123; //遍历整个栈内的键直到栈顶; objString = `$&#123;objString&#125;, $&#123;this.items[i]&#125;`; &#125; return objString; &#125; //这样下来除了toString方法, 其他几个方法的时间复杂度均为O(1), 也就是说都不用进行遍历.&#125; 使用栈1234const mystack = new Stack();console.log(peek);stack.push(5);stack.push(8); 六、用栈解决问题栈的实际应用十分广泛.在有回溯需求的问题上, 它可以存储访问过的任务或路径、撤销的操作.Java和C#用栈来存储变量和方法调用. 书上举的例子是一个十进制转二进制的进制转换问题. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//创建基于数组的栈class Stack &#123; constructor() &#123; this.count = 0; this.items = []; &#125; //定义用于操作数组的各项方法; push(element) &#123; this.items.push(element); &#125; pop() &#123; return this.items.pop(); &#125; peek() &#123; return this.items[this.items.length - 1]; &#125; isEmpty() &#123; return this.items.length === 0; &#125;&#125;function decimalToBinary(decNumber) &#123; const remStack = new Stack(); //在哪里使用栈就在哪里初始化栈; let number = decNumber; let rem; let binaryString = &#x27;&#x27;; while (number &gt; 0) &#123; rem = Math.floor(number % 2); //除法结果不为0时就将取整后的余数入栈 remStack.push(rem); number = Math.floor(number / 2); //除完一次取整继续除 &#125; while (!remStack.isEmpty()) &#123; //二进制字符 binaryString += remStack.pop().toString(); //将可出栈的元素链接为字符串, 清栈; &#125; return binaryString; //return出二进制数值 &#125;console.log(decimalToBinary(33333)); 总结下篇将是第四章《队列和双端队列》，可能会咕一段时间了，最近出了好多事情，有点累了。","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"《JavaScript数据结构与算法》第三章 数组","date":"2021-10-20T22:45:30.000Z","path":"2021/10/21/《学习JavaScript数据结构与算法》第三章 14000字笔记/","text":"前言本文包括数组操作方法、ES6新增数组功能、JS矩阵、类型化数组等； 前面是基础部分，如果你不是小白的话…个人认为可以从第三章开始?上一篇：《学习JavaScript数据结构与算法》第二章 ES和TS概述 添加元素于开头将新的数组元素直接添加至数组开头, 实操一般会使用unshift方法: 1234let numbers = [3, 4, 55];numbers.unshift(-2);unmbers.unshift(-2, 3);console.log(numbers); 从数组开头开始删除元素123for(let i = 0; i &lt; numbers.length; i++) &#123; numbers[i] = numbers[i + 1];&#125; 这相当于在数组序列号不变的情况下将所有数组元素整体左移了一个单位,但在这种情况下输出数组会发现数组的长度依旧未被改变,这说明数组中必然有一个元素的值为undefined:可以看到, 我们只是把数组第一位的值用第二位进行了覆盖, 第一位并未被删除. 但在实战中我们一般使用shift方法: 12let num = [1, 2, 3];numbers.shift(); 这种方法会直接导致数组长度减小. 三、二维 多维数组矩阵, 指包含二维数组在内的数组含有数组的结构; JavaScript只支持一维数组并不支持矩阵,但是可以用如下数组嵌套的方法来实现矩阵. 构建二维数组一维数组看作流水线, 把数组元素看作流水线上的一个个商品 ,那么二维数组就是流水线上一组组堆出了高度的商品: 就像这样: 12345 ︹ ︹ ︹ 6 4 3 3 5 9 2 1 0[ 3, ︺, ︺, 5, ︺, 6 ] 进行了一个维度的跨升, 但肯定是不能直接在代码里写这么个流水线的, 還是得這麽寫: 12345678[3, [6, 3, 2],[4, 5, 1],5,[3, 9, 0],6,] 四、JavaScript数组方法参考 方法 说明 concat 连接两个或者更多数组 foreach 对数组中每个元素执行函数,无返回值 every 对数组中每个元素执行函数, 如果每个元素的执行都返回true,every()返回true; filter 对数组中每个元素执行函数, 返回由所有执行时返回true的元素组成的数组 map 对数组中每个元素执行函数, 返回所有执行结果组成的数组 some 对数组中每个元素执行函数, 只要有一个元素返回true,some()就返回true join 将所有数组元素链接为一个字符串 indexOf 返回找到的第一个与给定参数相等的数组元素的索引号 lastIndexOf 返回找到的所有与给定参数相等的数组元素中索引号最大的那个, 即返回所有与参数相等的元素中最靠右的那个 reverse 颠倒数组元素的顺序,索引号不变 slice 依据传入的索引值将将索引范围内的元素作为新数组返回 sort 按照英文字母顺序对数组进行排序, 支持传入【指定排序方法的函数】作为参数 toString 将数组转换为字符串返回 valueOf 将数组转换为字符串返回, 与toSting相似 这其中的一些方法在函数式编程中十分有用; 这些我就不多记了, 都能查到. 值匹配搜索: indexOf &amp;&amp; lastindexOf先來看indexOf吧:indexOf() 返回與參數匹配的第一個元素的索引. 12console.log(numbers.indexOf(10)); //返回9, 因爲值10所在的索引為9;console.log(numbers.indexOf(100)); //返回-1, 因爲數組裏壓根沒有100; 對於 indexOf() 就是能找到的就會輸出目標數組元素的索引號, 找不到不存在的就輸出-1; 再來看lastIndexOf():lastIndexOf返回與參數匹配的最後一個元素的索引.意思就是:如果針對一個數組進行的查找產生了多個滿足條件的結果,豈會需選取最靠右的結果的索引號作爲返回值; 123numbers.push(10);console.log(numbers.lastIndexOf(10)); //10console.log(numbers.lastIndexOf(100)); //-1 五、ES6数组的新功能 新增方法 说明 @@iterator 返回一个包含数组键值对的迭代器对象,可以通过数组同步调用来得到数组元素的键值对 copyWithin 复制数组中一系列元素到同一数组指定的起始位置 entries 返回包含数组所有键值对的@@iterator(即索引號與值的键值对) keys 返回包含数组所有索引号的@@iterator(即包含索引號的對象) values 返回包含数组中所有值的@@iterator(即包含值的對象) includes 速查, 数组中是否包含某个元素,返回布尔值(這是出自ECMAS7的方法) find 可以注册回调函数, 其会根据回调函数规定的条件从数组中查找元素, 如果找到该元素则会返回. findIndex 可以注册回调函数, 其会根据回调函数规定的条件从数组中查找元素, 找到后会返回其索引号 fill 使用静态值填充数组 from 根据已有数组创建一个新数组 of 根据传入的参数创建一个新数组 @@iterator对象ES6为Array类增加了一个@@iterator属性, 需要通过Symbol.iterator来访问. 1234567let numbers = [1, 2, 3, 4, 5];let iterator = numbers[Symbol.iterator]();console.log(iterator.next().value);console.log(iterator.next().value);console.log(iterator.next().value);console.log(iterator.next().value);console.log(iterator.next().value); 形成對next()的反復调用，依次得到数组中的值: 返回包含索引號的對象:keys()keys返回包含數組索引號的@@iterator:示例: 12345let array = [5, 4, 3, 2, 1];const aKeys = array.keys();for (let i = 0; i &lt;= array.length;i++) &#123; console.log(aKeys.next());&#125; 公式: 12345let 數組名 = [元素1, 元素2, 元素3, 元素4, 元素5];const 自定義名 = 數組名.keys();for (let i = 0; i &lt;= 數組名.length;i++) &#123; console.log(自定義名.next());&#125; 至於後面那個done,它在英文中有”已完成”的意思,放在這裏即”是否已完成”,如果它的值為false説明這個數組還沒被迭代完成, 你可以看到, 儅數組迭代到了末尾,done變爲true;“一旦沒有可迭代的值, aKeys.next()就會返回一個value屬性為undedined, done屬性為true的對象”; 查找滿足函數條件的值: find() &amp;&amp; findIndex()這倆方法都能接收回調函數, 作用是去搜索能滿足回調函數條件的值,并且返回這些值.但是也有些區別, 我們先來看find()吧:find()返回找到的第一個滿足函數條件的值,重點在值.而findIndex()返回的是滿足條件的值的索引號(見示例末行);示例: 12345678910111213//我這裏把回調函數寫外面了,像addEventListener那樣寫裏面也可以的.let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];function multipleOf13(element) &#123; return (element % 13 == 0);&#125;console.log(numbers.find(multipleOf13)); //13//因爲數組裏滿足13倍數的就只有13一個, 所以直接返回了元素值13.console.log(numbers.findIndex(multipleOf13)); //12//數組裏滿足13倍數的只有13一個, 所以直接返回值13的索引號12. 依據傳入的參數創建新數組: Array.of()Array.of 方法根據傳入的參數創建一個新的數組: 12345let numbers3 = Array.of(1);let numbers4 = Array.of(1, 2, 3, 4, 5);//相當於let numbers4 = [1, 2, 3, 4, 5];console.log(numbers3);console.log(numbers4); 你也可以向其内部傳入數組作爲參數! 還記得前面説到的展開運算符嗎? 1234let numbers4 = [1, 2, 3, 4];let numbersCopy = Array.of(...numbers4);//相當於let numbersCopy = Array.of(1, 2, 3, 4);console.log(numbersCopy); 變數組某一段與另一段相同: copyWithin()copyWithin()方法複製(注意是複製,不會對受複製者有影響)數組中一系列元素到指定的位置進行替換.原理: 將參數二及其右邊的數組元素複製, 用於替換參數一及其右邊的相應個數的數組元素, 一定不會改變數組長度; 下面我先只改變參數一即插入點: 123let copyArray = [1, 2, 3, 4, 5, 6];copyArray.copyWithin(1, 4); //從索引1開始替換;console.log(copyArray); //(6) [1, 5, 6, 4, 5, 6] 123let copyArray = [1, 2, 3, 4, 5, 6];copyArray.copyWithin(0, 4); //從索引0開始替換;console.log(copyArray); //(6) [5, 6, 3, 4, 5, 6] 公式: 12let 數組名 = [元素1, 元素2, 元素3, 元素4, 元素5, 元素6];數組名.copyWithin(替換起始點, 複製起始點); //兩個點都包含本點; 六、类型化数组ES6的一大壯舉是給JavaScript這種弱類型語言加上了類型這一概念并且付諸實踐, 而類型數組即是這次技術革命的結晶之一… “類型數組用於存儲單一類型的數據, 它的語法是let myArray = new TypedArray(length), 其中TypedArray需要替換爲下表所列之一.” 不过，我去查了很多资料，这个东西现在跟前端的关联也有但说实话个人认为它应该是在数据处理方面，在进制和字节层面上使用，就平常写个页面之类的是用不上了。而且涉及的知识面比较广，这里我不过于深究防止误导，只说一下相关的一些概念和名词（这些书上都没写） 公式: 1let [自定義名] = new [數組類型]Array([數組長度]); 示例: 12let length = 5;let int16 = new Int16Array(length); 不説這麽多了, 上面説要看表, 那我先把表放下吧:| 類型數組 | 數據類型 ||–|–|| Int8Array | 8位二進制補碼整數 || Uint8Array | 8位無符號整數 || Uint8ClampedArray | 8位無符號整數(對, 沒寫錯) || Int16Array | 16位二進制補碼整數 || Uint16Array | 16位無符號整數 || Int32Array | 32位二進制補碼整數 || Uint32Array | 32位無符號整數 || Float32Array | 32位IEEE浮點數 || Float64Array | 64位IEEE浮點數 | 注意你不能再使用new Array()的那种方式填充类型数组： 123//错误示范, 这样是填不进去的, 括号里最多写一个参数来规定length; let int16 = new Int16Array(5, 4, 3, 2, 1); 而是应该: 12345let f64a = new Float64Array(8);f64a[0] = 10;f64a[1] = 20;f64a[2] = f64a[0] + f64a[1];console.log(f64a); “使用WebGL API、进行位操作、处理文件和图象时， 类型数组都可以大展拳脚。 它用起来和普通数组毫无二致，本章所学的数组方法和功能都可以用于类型数组。” 其实出自书中的这句话有错误。 首先在类型数组上调用 Array.isArray() 会返回false。此外，并不是所有可用于正常数组的方法都能被类型化数组所支持（如 push 和 pop），我也亲手试了下确实不能用，MDN尤其强调不要把普通数组和类型数组混为一谈。 DataView：是一种底层接口，它提供可以操作ArrayBuffer中任意数据的API。这对操作不同类型数据的场景很有帮助，例如：类型化数组视图都是运行在本地字节序模式，可以通过使用 DataView 来控制字节序。 ArrayBuffer 对象：用来表示通用的、固定长度的原始二进制存储空间（或者说…二进制数据缓冲区? ), 它是一个字节数组(在某些语言中称作byte array)。我们不能直接操作 ArrayBuffer 中的内容，而是要通过 类型数组 或 DataView 对象来操作,这两种方法我会各举一个例子，它们会将ArrayBuffer中的数据表示为特定的格式，由此来读写缓冲区的内容。前端方面只要是处理大数据或者想提高数据处理性能，一定少不了 ArrayBuffer. 看下这个ArrayBuffer, 他后面那个小括号里的数字就是指生成出了一个多少字节的存储空间： 1var buffer = new ArrayBuffer(16); 为了读写这段内容，需要为它创建一个视图，视图将把 ArrayBuffer 这个二进制存储空间内的数据格式化为一个(就本例来说)32位的有符号整数数组：这里使用类型数组方式进行读取: 1var int32View = new Int32Array(buffer); 现在即可以访问普通数组的形式进行访问： 123for (var i = 0; i &lt; int32View.length; i++) &#123; int32View[i] = i * 2;&#125; 或者使用DataView的方式进行读取: 12345var buf = new ArrayBuffer(32);//DataView的创建,需要提供ArrayBuffer实例作为参数：var dataView = new DataView(buf);//然后以不带符号的8位整数格式读取第一个元素:dataView.getUint8(0) // 0 以不带符号的8位整数格式，读取第一个元素得到0，因为ArrayBuffer对象内默认所有位都是0:可以点这看看大佬写的 总结下一篇：《学习JavaScript数据结构与算法》第四章 栈我寫了14000個字, 14000個字啊(震声)!你看我这么耐心的整理(雖然寫了很多廢話), 它现在比原作都長!這很累人的! 所以, 所以給它点個贊好嗎？","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"狀態稍微好些了","date":"2021-10-19T11:14:30.000Z","path":"2021/10/19/20211023随笔/","text":"v1.1.7概覽: 心態終於平衡了一點,至少能以正常的狀態和效率投入生活了. 昨天心态有点爆炸, 很抱歉把消极的情绪传递给大家. 也是今早下了決定要學習nodeJS, 因爲就我上半月對PHP的學習進度來看, 不適合把PHP继续学下去, 我对它完全提不起興趣.","tags":[]},{"title":"我%@#@$$*&(*@?","date":"2021-10-19T11:14:30.000Z","path":"2021/10/19/我真是操了/","text":"v1.1.6概覽: 更新了一下7月份以來的文章. 我真是操了, 我他媽在這備賽備了這麽長時間, 到最後就隨便找了個理由把我開了?嗯? 早晨在教室吃了個麵包被系主任看見, 這個月初請假走沒跟你説? 那你他媽倒是早説啊,爺在這備賽那邊自考本也放了Vue學到一半直接截停今天你跑來跟我説wsy因爲你表現不好被開了,不是你實力問題. 表現不好被開了,怎麽你這是去比賽選空乘小姐是吧? 我要不要送你個狗繩子你牽著我?我那天回家都給校裏請假了回來你TM直接給我下定論説我無組織無紀律,怎么?你都不回家看看你媽的?缺守紀律的那你去找個學生會的那群狗腿子來多好啊?你TM來禍害我幹啥? 我就一死宅男? 外面一大群好學生呢巴不得給你多磕幾個頭拿點分呢. 再説多久以前出的這個事?你月初早放P啊直接説今天你吃麵包被看見了你請假沒跟我説所以明天給我滾蛋不就完了?你讓我在這耗一個多月幹啥? 害擱這做你那全媒體運營師大賽的白日夢呢? 就你分那人?今天還TM安慰我說你不要太難過你一定能帶著你們隊把那個隊幹下去的, 我乾尼瑪? 你分隊把最好的那人都整那個隊去了,鬼TM信你那是隨機分的隊當時拿個輸入法抽的籤我就坐你旁邊,你是覺得我不會打字還是沒長眼? 一開始這隊就是棄子,你現在讓我帶著你當初隨便招進來的這一堆人翻盤? 做夢呢? 你直接說我找到了個更好的程序,暫時不用你了我TM滾回去學點別的不好? 我進來之前就找了個大三的儅程序,擱著惡心人就算了,直接讓我走不就完了?我還滿懷希望的擱著寫了一個月的div還TM天天想怎麽能寫的快點,寫這玩意有個P用你自己沒點數?","tags":[]},{"title":"读《学习JavaScript数据结构与算法》 第二章","date":"2021-10-14T11:44:41.000Z","path":"2021/10/14/读《学习JavaScript数据结构与算法》 第二章/","text":"前言第一章是JS基础, 我就先不记录了.我看到前面这两章跟数据结构关系不大,反倒有很多ES6的新知识.打算先把这些集中记录下来,到后面的数据结构章节会开篇单独记录. 二、模板字面量支持换行一种针对字符串的书写方法,以前我们用被引号括住的字符来表示字符串,但是每到换行就得用特殊的处理方法,这并不符合常规的书写习惯,在ES6中引入的模板字面量写法很好的解决了这个问题.将引号替换为``,这将使得浏览器能够将代码中字符串的换行正确的解析出来,而不是直接忽略: 123456console.log(`我不知道`) 但是不要把它放在innerHTML里使用,那是无效的: 123var div = document.querySelector(&quot;div&quot;);div.innerHTML = `got it` 大多使用在JS中需要提供字符串的时候,使用双引号来书写就无法支持换行.使用模板字面量则可以很好的解决这个问题. 拼接方式模板字面量有自己的一种字符串拼接方式,而不是像以前那样直接使用加号来把字符串和变量拼接在一起.例: 1`字符串前段$&#123;变量名&#125;字符串后段` 1234const name = &quot;瓜&quot;; console.log(`你**劈我$&#123;name&#125;是吧! 我! 唉! 好哇!`); 四、展开运算符将数组展开为单个的数组元素,每个元素之间相隔一个字符距离;可以让你免于在函数上亲手写上一大堆难看的参数的垃圾体验;公式: 12let 数组名 = [元素1, 元素2, 元素3];console.log(...数组名); 你可以用它来直接将一整个数组内的元素作为参数传入一个函数,各个分离出的数组元素也会刚好对应到各个参数上: 123456let params = [3, 4, 5];console.log(sum(...params));//相当于写了console.log(sum(3,4,5));function sum(x = 1, y = 2, z = 3) &#123; return x + y + z;&#125; 可用于进行对变量值的互换, 而不需要创建第三个变量,是的,现在当你的C语言老师问你”我要把一瓶酱油和一瓶醋对调,一共需要几个瓶子”的时候你可以自信的跟他说:”两个”. 1234let var1 = &#x27;a&#x27;;let var2 = &#x27;b&#x27;;[var1, var2] = [var2, var1];console.log(var1, var2); //b a; 2.属性简写感觉实用性不高,其实这个方法 是基于数组解构实现的: 123let [x, y] = [&#x27;a&#x27;, &#x27;b&#x27;];let obj = &#123;x, y&#125;;console.log(obj); 3.简写方法名使用更加简单的方式来声明一个方法,其实我们经常在Vue项目里见到这两种写法: 123方法名() &#123;//函数体;&#125; 123方法名: function 函数名() &#123;//函数体;&#125;","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"CSS3 touch-action设置移动端拖动行为","date":"2021-10-13T12:09:33.000Z","path":"2021/10/13/CSS3 touch-action设置移动端拖动行为/","text":"前言touch-action是一个用于解决 [移动端屏幕拖动默认行为造成的诸多不便] 的CSS属性,它可以改变浏览器对于”拖动”这一行为的应对策略, 我挑了几个感觉比较用得上的来记录,每一个都做了下演示. 三、注意注意除了none之外, 其他几个属性的”允许某方向上的拖动”, 都是指按下去后在那个可拖动方向的执行的首次拖动,只有那一次是被允许的.但若是我在pan-up的情况下按下去, 先向下拖了(这是能拖的), 但是我不松开手继续往左往右的乱拖一气然后再往下拖, 那就不能下拖了,可以去试一下: 12345678910div &#123; position: absolute; top: 100px; left: 100px; height: 60px; width: 60px; touch-action: pan-up; border-radius: 45%; background-color: rgba(0, 255, 255, 0.63);&#125; 123&lt;div&gt; div01&lt;/div&gt; 123456//JS,其实不用写;var div = document.querySelector(&quot;div&quot;);div.addEventListener(&quot;touchmove&quot;, function (e) &#123; div.style.top = e.touches[0].clientY - 25 + &quot;px&quot;; div.style.left = e.touches[0].clientX - 25 + &quot;px&quot;;&#125;) 你必须得把手松开然后才能再下拖; 总结_","tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://example.com/tags/CSS3/"}]},{"title":"MySQL设置数据格为空白或NULL","date":"2021-10-12T02:40:30.000Z","path":"2021/10/12/MySQL设置数据格为空白或NULL/","text":"前言昨天打算建个数据库来做个项目, 有个需求是把数据库中的一些格子设置为空白,但是不知道怎么做,感觉直接传个空字符串进去也不能算是”空白;”我先尝试了不传值(现在来看是真的有点蠢) ,然后PHPMyAdmin提示”这行要有仨值,你就给了俩”甚麽意思呢, 比如第一列和第二列我都给了5个数据,那么现在这俩都是5行,但是第三列我只给了俩数据,这样3 4 5行都缺了一块,就会出现这个错误; 总结_","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}]},{"title":"20211010 PHP筆記","date":"2021-10-10T15:20:15.000Z","path":"2021/10/10/20211010 PHP笔记/","text":"前言 二、mysqli_multi_query()公式: 1mysqli_multi_query( 使用的数据库连接, 需要执行的SQL语句); 既然使用了这个方法,那么必然是有多条SQL语句需要被执行,但这个方法看起来又只能传两个参数,这…?可以选择累加的方法, 在一个变量上累加多条SQL语句,使用分号隔开:例: 12$sql = &quot;SELECT Lastname FROM Persons ORDER BY LastName;&quot;;$sql .= &quot;SELECT Country FROM Customers&quot;; 这些SQL语句会被逐条执行,还是要注意一下执行顺序的; 如果第一条命令执行正常,那么该方法将返回一个true(否则返回false),对于第一条命令返回的结果,必须使用mysqli_store_results()或mysqli_use_result()来进行接收:mysqli_store_results()将全部命令的执行结果直接取回客户端, 效率更高; 123456789101112do &#123; if($result=mysqli_store_result($link)) &#123; $data[$i]=mysqli_fetch_all($result); //从结果中取得所有数据并以关联数组的形式存储; mysqli_free_result($result); //取得$result后释放其所占内存; &#125;else&#123; $data[$i]=null; &#125; $i++; if(!mysqli_more_result($link)) break;&#125;while (mysqli_next_results($link)); 四、mysqli_fetch_all()从变量中取得所有数据并以关联数组的形式存储;公式: 1mysqli_fetch_all() 例: 12//这是在接收mysqli_multi_query()的结果,外面包着的循环略;$data[$i]=mysqli_fetch_all($result); 六、flock()独占锁定同一时刻只有一个单独的用户在操作文件，这样是没有问题的。但是如果两个或者更多用户同时操作同一文件的话，程序就会出现错误。解决这种问题的方法就是，在使用 PHP 向文件中写入时，暂时锁定该文件.改变当前文件的锁定状态,flock执行完毕返回布尔值:| mode | 说明 ||–|–|| LOCK_SH | 取得共享锁定（读取的程序) || LOCK_EX | 取得独占锁定（写入的程序) || LOCK_UN | 释放锁定（无论共享或独占) | 1if ( flock( $file, LOCK_EX ) ) &#123; 使用了 flock() 函数对文件进行了加锁操作，那么调用 fclose() 函数时，文件会自动解锁，但最好还是在文件写入完成后加上解锁语句 八、fclose()fopen()打开文件,操作完之后总还是要关闭文件的;公式: 1fclose(文件路径) 八、unset()销毁一个已经给定的变量;公式: 1unset(变量名); 例: 12//销毁数组arr中第4个元素;unset($arr[3]); 十、file_get_contents()获取某个文件中的所有内容,公式: 1file_get_contents(&#x27;文件路径&#x27;); 例: 1$str = file_get_contents(&#x27;mysql.txt&#x27;); 十二、explode()将字符串以某个字符为界割裂成一段段,并且做成一个数组返回:完成后可以通过选取数组元素的方法:arr[?],来选取某段割出的数组元素,选出来的是字符串或者数字;公式: 1explode(分割标志, 字符串); 例 123//比如以&quot;@_@&quot;这段字符作为分割标记;$str=我@_@不@_@知@_@道explode(&#x27;@_@&#x27;, $str); 十四、点等号”.=”基本相当于JS中的累加号,可以拼接字符串和数字, 对, 对于数字型也只能是进行拼接: 1234567$a = 1;$b = 3;$c = 2;$c .= $a; $c .= $c;echo $c; 总结_","tags":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"CSS3 偽元素","date":"2021-10-04T13:15:48.000Z","path":"2021/10/04/CSS3 僞元素/","text":"前言CSS3新增的伪元素要求使用双冒号了,但对于以前的伪元素则是单双皆可.本文中除了::selection ,都是单双皆可的. 二、::after before初始位置也位于元素左上(对,我没说错)但也不是紧贴左上,有一段很小的距离. 1234567.box::after &#123; content: &quot;&quot;; width: 10px; height: 10px; border-top: 2px solid #4feff5; border-right: 2px solid #4feff5;&#125; 其他特性同::before; 三、::first-letter对第一个文字所占有的区域进行样式规划; 1234.text::first-letter &#123; color: rgb(27, 245, 216); background-color: grey; &#125; 1&lt;p class=&quot;text&quot;&gt;访问量已破万,感谢大家一年来的支持...&lt;/p&gt; 总结复习一下伪元素~早上起床看到访问量破万,高兴了一天,感觉这一年的付出都值得了,哈哈. 记得是20年9月末来到CSDN的,那时候我还是个HTML都不会的高三毕业生,每天愁眉苦脸的看着一大堆书本,和我那让人看不明白的舍友和同学. 时间过得好快,转眼我已是那年的大二学长, 不知不觉也已经在CSDN呆了这么久, 这一年在CSDN收到了许多善意的帮助, 我也如愿以偿为社区尽了一份绵薄之力, 最重要的收获是, 我认识到世界上还有这样一群人, 这样一群每天加班到深夜, 每天面对铺天盖地的字符和BUG, 却依旧乐观向上的人, 他们把我拖出了自己的泥潭.","tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"解决纵向滚屏导致的轮播图异常","date":"2021-09-29T08:38:46.000Z","path":"2021/09/29/解决纵向滚屏导致的轮播图异常/","text":"前言今天手机端页面,需求是做一个上滑翻页的效果,先写了一个demo,没有什么问题,用touchstart,touchmove和touchend解决了滑动翻页的问题,然后运行起来看着都还不错! 接着就开始下饭了,在照着demo的纵向轮播结构向里面添加了诸多页面内容后,页面出现了一种奇怪的切换动作:慢慢翻还好,只要翻快点不是翻多了看不全就是翻少了多出来一截. 二、解决方案那就去阻止默认行为吧,最后倒也真的解决了. 需要对操控&lt; ul&gt;拖动的代码上做一些改动,要阻止拖动 过程中 默认行为的出现,那必然也要是在过程中做手脚,也就是”touchmove”时间触发阶段: 将代码从: 1234//&quot;roll&quot;就是整个&lt;ul&gt;; roll.addEventListener(&quot;touchmove&quot;, function (e) &#123; nowPos = e.touches[0].clientY; &#125;) 改动为: 12345//&quot;roll&quot;就是整个&lt;ul&gt;; roll.addEventListener(&quot;touchmove&quot;, function (e) &#123; nowPos = e.touches[0].clientY; e.preventDefault(); &#125;) 在鼠标拖动中每一刻都会执行这个事件监听函数,也就每一刻都会阻止默认行为. 啊…就这样,加上就好了,没有什么特别绚丽的操作.","tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"使用HTML5 classList在JS中操作类名","date":"2021-09-28T12:32:40.000Z","path":"2021/09/28/使用HTML5 classList在JS中操作类名/","text":"@TOC 一、classList.add()你可以使用这个方法来为一个元素添加多个类名,当然,只加一个也是可以的,只传一个值就好了. 公式: 1element.classList.add(需要加入使用的类名1,需要加入使用的类名2,需要加入使用的类名3); 例: 12345.class1 &#123; height: 100px; width: 100px; background-color: grey;&#125; 1&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; 1document.getElementById(&quot;div1&quot;).classList.add(&quot;class1&quot;); 三、classList.replace()将某个旧类名替换为一个新的类名;公式: 1element.classList.replace(&quot;旧类名&quot;, &quot;新类名&quot;); 例:那我们现在让这个灰方块变个色: 1234567891011.class1 &#123; height: 100px; width: 100px; background-color: grey;&#125;.class2 &#123; height: 100px; width: 100px; background-color: skyblue;&#125; 1&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; 12document.getElementById(&quot;div1&quot;).classList.add(&quot;class1&quot;); document.getElementById(&quot;div1&quot;).classList.replace(&quot;class1&quot;, &quot;class2&quot;); 五、classList.contains()判断,该类是否已经被当前元素使用,返回布尔值;也可以传入多个类,但是只要传入的类中有任何一项被该元素使用,就会返回true,不需要全部使用;公式: 1element.classList.contains(&quot;待检类名1&quot;, &quot;待检类名2&quot;,&quot;待检类名3&quot;); 例: 1&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; 123document.getElementById(&quot;div1&quot;).classList.add(&quot;class1&quot;, &quot;class2&quot;);console.log(document.getElementById(&quot;div1&quot;).classList.contains(&quot;class5&quot;, &quot;class3&quot;));console.log(document.getElementById(&quot;div1&quot;).classList.contains(&quot;class1&quot;, &quot;class3&quot;));","tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"2021.09.27 MySQL笔记","date":"2021-09-27T10:11:20.000Z","path":"2021/09/27/2021.09.27 MySQL笔记/","text":"一、展示当前存在的所有数据库1SHOW DATABASES; 三、创建一个数据表公式: 1CREATE TABLE 数据表名(列首1 数据类型, 列首2, 数据类型); 例: 1CREATE TABLE chart3(url VARCHAR(255), texts VARCHAR(255), imgs VARCHAR(255)) 一定注意最后一对后面不要再加逗号,不然会报错 五、存入(添加)单条记录1INSERT INTO 数据表名(列首1, 列首2, 列首3) VALUES(值1, 值2, 值3); 键值关系需要对应,只能在已有列下插入,使用不存在的列名将报错; 七、查询并展示数据表中的数据12SELECT * FROM 数据表名; //查询&amp;展示所有字段;SELECT 字段 FROM 数据表名; //查询一列; 九、同时更新多个数据表的数据:公式: 1UPDATE 数据表2, 数据表1 SET 数据表1.字段=???, 数据表2.字段=2000 WHERE 数据表1.字段=1 AND 数据表2.字段=1; 例: 1UPDATE chart2, chart1 SET chart1.age=1000, chart2.age=2000 WHERE chart1.id=1 AND chart2.id=1; 十一、查找数据表中不重复的某项公式: 1SELECT DISTINCT 要查询的字段 from 数据表名 WHERE 条件1 AND(或OR) 条件2; 例: 12SELECT DISTINCT * FROM employee where id=3 OR id=4;SELECT DISTINCT * FROM employee where id&gt;4; 对于某个值,只要不存在与其相同的另一个值,其就会遭到列出; 十三、字段求和计算某项数据的总和;公式: 1SELECT SUM(字段) FROM 数据表名; 例: 1SELECT SUM(salary) FROM employee; 十五、查询某字段最大值对某个字段进行数据个数统计:公式: 1SELECT MAX(字段) FROM &quot;数据表名&quot;; 例: 1SELECT MAX(salary) FROM employee; 十七、表连接:内连接公式:从 |数据表1|和|数据表2| 中选取 |数据表1|的|字段1字段2| 和 |数据表2|中的|字段1| ,条件是 |数据表1| 里选出来的那个字段1名字必须和字段2的相同; 1SELECT 数据表1.字段1, 数据表1.字段2, 数据表2.字段1 FROM 数据表1, 数据表2 WHERE 数据表1.字段1 = 数据表2.字段1; 外连接__ 总结记一些乱七八糟的东西.","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}]},{"title":"解决PHPStudy8.1.1 mySQL服务启动失败 数据库工具报错卡死","date":"2021-09-26T09:12:56.000Z","path":"2021/09/26/解决PHPStudy8.1.1 mySQL服务启动失败 数据库工具报错卡死/","text":"问题描述：然后就是mySQL服务无法启动,老倒霉蛋了,一点都不惊讶甚至觉得就该这样. 解决方案： 启动注册表,找到mySQL文件,删除(是否起效不明); 进入C盘尝试寻找mySQL文件删除,确保旧的mySQL配置文件不会干扰新安装的mySQL,寻未果,遂放弃; 启动cmd,输入指令sc delete mysql, 指令被阻止 使用管理员身份启动cmd,再次执行sc delete mysql,执行删除mysql成功; 再次尝试链接mySQL, 依然无法启动,phpmyAdmin无法登入. 重启phpstudy,启动mysql服务,无果. 尝试卸载mysql5.7.26,卸载成功,但是再次下载时弹出报错导致无法下载; 怒不可遏; 尝试下载mysql8.0.12,下载成功. 尝试启动mySQL服务,启动失败. 进入cmd查找端口占用,发现3306端口遭到PID为7772的mysqld进程占用,注意此时netstat -ano的检测结果只有一项进程. 进入任务管理器,终止mysqld解除占用. 再次尝试启动mysql8.0.12服务,启动成功. mysqld主动请求启动,允许启动,mysqld启动成功,mysql服务未终止. 再次检测端口占用发现3306被PID7692的mysqld进程占有,但是在执行netstat -ano时的结果是6项进程而不是启动成功之前检测的仅1项进程; 然后打开数据库工具SQL_Front发现报错不能用(打开就报错然后卡死),推测数据库版本过高,遂卸载8.0.12版本mySQL; 尝试下载5.7.26版本,依旧弹出报错无法下载,遂放弃; 下载5.0.96版本,下载完成,启动成功; 数据库工具可以正常使用;两小时后发现phpmyAdmin不能使用,根据报错原因判断为当前mySQL版本过低导致,于是卸载5.0.96版本,切换为5.5.29版本,两个数据库工具均可正常使用;了:","tags":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"hover效果平滑过渡至初始状态","date":"2021-09-24T12:26:31.000Z","path":"2021/09/24/讓hover效果平滑過渡回初始狀態/","text":"前言 一、原因分析hover中的transition在鼠标划过时被触发,但在鼠标离开后,hover中的CSS样式瞬间消失,导致动画消失并且样式直接回到无hover状态. 附 整的活123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;层叠&lt;/title&gt; &lt;style&gt; body &#123; padding: 0; margin: 0; background-color: black; width: 100%; height: 100vh; align-items: center; justify-content: center; display: flex; &#125; #main &#123; perspective: 500px; position: relative; width: 100px; height: 200px; background: rgba(0, 0, 0, 0); transform-style: preserve-3d; /* 猜测:规定hover过渡效果的持续时长 */ transform: rotate(-30deg) skew(25deg); /* skew? */ &#125; #main div &#123; height: 200px; width: 100px; transform-origin: 0 50%; background: -webkit-linear-gradient(top, #8d01ff, #ffffff); &#125; #main:hover div:nth-child(1) &#123; transform: translate(120px, -120px) rotateY(-165deg); z-index: 300; &#125; #main:hover div:nth-child(2) &#123; transform: translate(90px, -90px) rotateY(-170deg); z-index: 500; &#125; #main:hover div:nth-child(3) &#123; transform: translate(60px, -60px) rotateY(-175deg); z-index: 600; &#125; #main:hover div:nth-child(4) &#123; transform: translate(30px, -30px) rotateY(-180deg); z-index: 900; &#125; /* #main被触发之后nth-child(1)会进行效果 */ div:nth-child(1) &#123; position: absolute; transform: translate(30px, -30px); transition: all 1s linear 3s; opacity: 0.9; &#125; div:nth-child(2) &#123; position: absolute; transform: translate(60px, -60px); overflow: hidden; transition: all 1s linear 2s; opacity: 0.75; &#125; div:nth-child(3) &#123; position: absolute; transform: translate(90px, -90px); transition: all 1s linear 1s; overflow: hidden; opacity: 0.5; &#125; div:nth-child(4) &#123; position: absolute; transform: translate(120px, -120px); transition: all 1s linear; overflow: hidden; opacity: 0.25; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;main&quot;&gt; &lt;div class=&quot;paper1&quot;&gt; &lt;/div&gt; &lt;div class=&quot;paper2&quot;&gt; &lt;/div&gt; &lt;div class=&quot;paper3&quot;&gt; &lt;/div&gt; &lt;div class=&quot;paper4&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 总结老活新整.","tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"讓CSS動畫中途停止並維持姿態","date":"2021-09-24T11:24:26.000Z","path":"2021/09/24/让CSS动画中途停止并维持姿态/","text":"前言我曾经遇到过一个难题.我需要让一个摆动的房子从塔吊上落下,但点击落下途中,房子需要维持落下瞬间摆动的角度.当时把我难坏了,刚开始我希望能获取到房子当前摆动的角度,并且在下落的瞬间赋值给房子的transform:rotate(),但这是实在是太麻烦了,不会是最优解. 但其实只要一个属性就能解决这个问题. animation-play-state 总结一点小经验 :一)","tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"理解JavaScript的宏微任務","date":"2021-09-24T10:52:15.000Z","path":"2021/09/24/理解JavaScript的宏微任务/","text":"前言JS是一门单线程语言,这意味着正常执行的话所有任务堆在一起需要排队,当然,也就像细水管里的小球一样,一个流不出去,后面的都得等着.这未免不太不合理.主线程完全可以把目前无法执行或者不必执行的任务先挂起,就像堵车的时候把最前面那个慢吞吞的车给掀了,让大家先过. 等到这个被挂起的程序能执行了也该执行了,再把它放下来.这是同步任务和异步任务,但其实异步任务还可以细分为宏任务和微任务. JavaScript中的诸多异步任务在执行时会被分拣入两条队列,即宏任务队列和微任务队列,分配到这两条队列中的各个任务会依照自己在队列中的顺序被依次执行,直到队列中的任务被拣取完成. 一、图文示例我做了个图,或许能更加直观一些…?(我后面看了一下,图里有些表达不明确的地方,如果你看的时候文本和图例发生冲突,你还是以我的文本为主,好吧?) 正常任务(也就是本文中宏任务,其实宏任务和正常的任务队列并不是下图中挑选的关系.)放到下一轮事件循环，微任务追加到本轮事件循环,能立即执行的任务就立即执行. 到了第二轮之后会开始执行上一轮剩下的代码,这里其实首轮剩下的所有代码在第二轮都会作为第二轮的宏任务素材,图上表达的不够明确,这图算是有利有弊吧. 第一轮执行就是从所有代码里挑微任务和能立即执行的任务出来执行,然后剩下不能立即执行的就都(加入宏任务队列)剥掉一层放到下一轮,必须要剥一层,不然永远也执行不完的. 这样都扔到下一轮了,就可以完美的重复第一轮的操作了:再从头执行一次,把剥完一层壳之后露出来的微任务放到微任务队列,可立即执行任务马上办掉,剩下的剥一层壳再扔给下一轮.然后把这一轮的微任务处理掉. 这是第二轮执行:不过这个图例就只有两轮,就没有第二轮剥壳扔下一轮这一步了…","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"无SSH工具部署网站到火腿云","date":"2021-09-22T02:18:10.000Z","path":"2021/09/22/無SSH工具部署網站到火腿云/","text":"前言画了9块买了个火腿云服务器来部署我的项目,但是网上几乎查不到火腿云的教程,而且其他教程大多是自建服务器部署网站的教程,看起来体验也不是很好,决定记录一下部署成功的流程. 总结这是我总结出的一些个人经验,如果这些帮到了您,我很高兴.如果您发现了文章的不足,还望您的指点..","tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"Element穿梭框Transfer与进度条组件绑定","date":"2021-09-17T03:38:15.000Z","path":"2021/09/17/Element穿梭框Transfer与进度条组件绑定/","text":"前言最近做的后台管理系统里使用了Element组件Transfer做了一个工作表,然后加了一个进度条来表示工作进度,我希望能将两者绑定起来; 总结_","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"Vue3+CLI4 使用Element-ui","date":"2021-09-15T13:58:59.000Z","path":"2021/09/15/Vue3+Cli4環境使用Element-plus/","text":"前言使用中报错请看第一大节,准备引入请看第二大节. 1.关于引入组件我遇到一个奇怪的点,官方文档和很多大佬都说要引入组件,但是我在以前做Vue2项目的时候,包括现在的Vue3项目,用Element都是不引入组件直接粘过代码来就能用的,我不知道这是否合理,但确实是我遇到的情况,就以这次Vue3项目来示例吧: 你可以看到我没有在任何地方引入组件,仅仅是在官方网站的组件库里复制代码和样式到我的文件里,就可以正常使用.最后更离谱一点我把element.js也注释了,但是还是没有任何影响:","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"Vue3+cli4.5.x 中使用Echarts5","date":"2021-09-14T15:12:30.000Z","path":"2021/09/14/Vue3+Cli4環境使用Echarts5/","text":"前言最近在做这个项目,这也是驱使我探求Vue3和Echarts结合方法的原因,虽然还没做完,我挑一个页面给你们看看吧.你可以看到右下角还没有对齐,然后轮播图也还没做,不过这都不重要了,引你进来的目的已经达到了. 一、按需引入这个项目我用的是全局引入,图个方便,没讲究那么多,但我估计大家还是喜欢按需引入吧.. 12import * as echarts from &#x27;echarts&#x27;;//只加这句就行了,而且也不用use这个东西 12345678910111213141516171819202122//组件中import * as echarts from &#x27;echarts/core&#x27;;import &#123; CanvasRenderer &#125; from &#x27;echarts/renderers&#x27;;import &#123; BarChart &#125; from &#x27;echarts/charts&#x27;;//格式: import &#123; 图表类型 &#125; from &#x27;echarts/charts&#x27;import &#123; TitleComponent, TooltipComponent, GridComponent&#125; from &#x27;echarts/components&#x27;;// 提示框，标题，直角坐标系组件，组件后缀都为 Componentecharts.use([ TitleComponent, TooltipComponent, GridComponent, BarChart, CanvasRenderer]);// 注册必须的组件 好麻烦,我不想每个组件都来这么一段… 三、4小时血泪史1.第一个困难前面说到接口改动了,这样的话我们再用原来的老套路: 12import echarts from &#x27;echarts&#x27;Vue.prototype.$echarts = echarts 是不行的,会报错:main.js?56d7:6 Uncaught ReferenceError: Vue is not defined.这个就是我一直报的错误,其实倒也不是因为接口改了的问题,这个错误是因为当时我不知道Vue3里不能再用Vue.xxx来创建实例,结但是阴差阳错让我找到了这个问题的解决方案. 至于老式的,现在我回来试了一下,Vue替换成app…也不行:虽然只是一个警告,但页面是渲染不出来的. 2.第二轮太阳而另一种报错情况是我根据另一位博主的教程来写的,他改进了第一种错误的写法,建议在main.js中使用: 1234const app = createApp(App).mount(&#x27;#app&#x27;)import * as echarts from &#x27;echarts&#x27;app.$echarts=echarts 其实上面这部是对的;而且这样在使用时应该是可以直接使用”$echarts”来初始化Echarts;但是下面这步我没看明白,所以当时没有采用. 123let myChart = this.$root.echarts.init( document.getElementById(&quot;myChart&quot;) ); 现在回来看看其实可以直接 123let myChart = $echarts.init( document.getElementById(&quot;myChart&quot;) ); 不过他的答案还是给了我的很大的帮助,让我认识到了在main中添加 1&#x27;import * as echarts from &#x27;echarts&#x27; 的必要性.这最终引导我走向了正确的道路.我尝试了很多次,但是错误基本就是这两个了","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"Vue3+cli4.5.x 中使用“vue-axios“","date":"2021-09-09T14:02:59.000Z","path":"2021/09/09/Vue3+cli4.5.x 中使用“vue-axios“/","text":"前言我是在cli4.5.x + vue3环境下做的,所以代码看起来可能有些离谱. 这是一个基于vue并进行了轻度封装的axios包,里面整合了vue环境下会用到的一些axios相关. 二、使用方法12345//作者原话,大意是我开发的这个东西好处不大//它可以将axios与vue实例绑定,这样你使用axios时就不用每次都引入(axios)了It only has a small benefit that it binds axios to the vue instanceso you don&#x27;t have to import everytime you use axios. 使用它之后你可以用一种特殊的语法来进行请求,这是作者写的三种使用方法,虽然我怎么看这都是一种: 1234567891011121314//在我的环境里不能直接用,啊...反正先别用就好了,我会说修改方法的Vue.axios.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;)//这个是可以直接用的this.axios.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;)//这个方法vv在我的环境下不能用,而且没找到修改办法.this.$http.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;) 我看到前面加了this,这是普通请求方法所不具备的, 可能会在某些时候提供便利…?但是你也看到我的标注了吧? 有些是不能直接在vue3+cli4.5.x的环境下使用的,下面是我记录的修改方法,至少这能让他们正常工作… 2. 第二种方法:1234//这个是可以直接用的this.axios.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;) 哦,这个能用,那没事了… 三、与普通请求方法的区别?你可能会有点疑问:”啊? 博主,他给的这请求方法好像不装vue-axios也能用啊?” 其实一开始我也有这个疑问,感觉….它们真的好像. 那我现在把这些都注释掉,但vue-axios存在时的所有方法都维持原状:结果:调用栈溢出,我也不知道为什么报这个错,但是好三个项目都是这个结果,只能说做下参考吧…然后解引入vue-axios的注释就没事了.我觉得vue-axios提供的方法和普通方法的区别大概在于axios前面的this吧…这或许能提供什么便利…?","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"解讀ES6 Promise","date":"2021-09-06T16:15:26.000Z","path":"2021/09/07/解讀ES6 Promise/","text":"@TOC 一、Promise是什么呢…一种异步编程解决方案,多用于一般很耗时的网络请求(JS是单线程语言,如果使用同步来进行程序,中途用户一旦要进行网络请求,会与同步执行的程序出现冲突,称为”阻塞”,线程阻塞进行操作也无法执行); 在执行一些复杂的回调时,使用Promise可以较好的避免回调地狱; 特性: 本质是构造函数; 自身带有 resolve | reject | all() 等方法; 原型中还提供了 then() | catch() 两种方法; 三、reject使用Promise的时候需要先作为参数传入,具体见下面例子; reject()方法在执行失败后回调Promise,然后拿到错误报告传给catch().在resolve回调的过程中如果出错,程序也会将错误报告推送给catch(). 返回错误报告,在调用到catch的时候catch里必然就已经有了错误报告(不然也不会调用catch()),于是事先在catch()里写处理方法的时候就可以拿一个参数来接收(一般会用error或者err): 1234567//先传入两个方法; promise((resolve, reject) =&gt; &#123;&#125;) .then() .catch((error) =&gt; &#123; console.log(&quot;出错啦:&quot; + error); &#125;) 个人觉得这两个方法成功的将Promise和其他请求方法区分开了,也建立了Promise独有的优势; 依照Promise的思想,其将请求的各个步骤交付专门的方法进行处理: resolve方法在成功的时候回调Promise并提供数据给then(). reject方法在失败的时候回调Promise并且提供错误报告给catch(). 在then()里专门处理数据,而不是拿到后夹在各个请求之间直接原地处理. 就算是报错也有catch()专门负责; 五、all该方法针对并发的异步操作,在所有异步操作执行完并且都成功的时候才回调Promise.在使用的时候您可以将需要并行执行的Promise放到各个方法里,然后使用Promise.all([ ]) 在数组里写上需要调用的方法,即可并行执行各个Promise; 这看起来有点像axios.all()发起的并发请求? 确实,我也这么觉得… 123456789101112131415161718192021222324252627282930function promise1()&#123; let work1 = new Promise(function(resolve, reject)&#123;&#125;) return work1;//return一下,不然Promise.all的数组里收到的不是Promise对象;&#125; function promise2()&#123; let work2 = new Promise(function(resolve, reject)&#123;&#125;) return work2;//return一下,不然Promise.all的数组里收到的不是Promise对象;&#125; function promise3()&#123; let work3 = new Promise(function(resolve, reject)&#123;&#125;) return work3;//return一下,不然Promise.all的数组里收到的不是Promise对象;&#125; //在此处同时调用三个方法,返回三个Promise; Promise.all([ promise1(), promise2(), promise3(), ]) .then((res) =&gt; &#123; console.log(&quot;拿到了!&quot; + res); &#125;) .catch((error) =&gt; &#123; console.log(&quot;出错啦:&quot; + error) &#125;); 等到它们都执行完后,then()才会调用(catch()依然是出错就调用)。 3个异步操作返回的数据都在then里以数组的形式存储着, 这时候给then一个参数来接收结果即可.","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"GitHub改爲token驗證後提交代碼","date":"2021-09-04T13:58:04.000Z","path":"2021/09/04/GitHub改为token验证后提交代码/","text":"三、利用token提交代码第一种方法这或许也是最常用的方法吧… 1.把要提交的文件放进本地仓库1git add . 2.提交1git commit -m &#x27;&lt;对本次提交的备注&gt;&#x27; 3.push入库1git push 第二种方法这是一种很简单的方法,我个人喜欢用这个.可以不经过拷贝直接将本地仓库push进库(需要两条命令配合使用) 1git remote add origin &lt;提交到的仓库地址&gt; 然后 12//将已绑定的本地仓库push上去;git push -u origin master 这个方法也要绑定token,否则会报: 1&quot;remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.&quot; 总结这两天找了个element的项目来做,下篇大概率会是element使用方面的文(如果接下来两天内没有让我翻车的重大BUG的话)感谢你读下来,这些是我的个人见解,可能有些浅薄,如果您能指出我的错误,在下感激不尽了.","tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"详解Web API requestAnimationFrame","date":"2021-09-01T14:12:41.000Z","path":"2021/09/01/详解Web API requestAnimationFrame/","text":"详解Web API requestAnimationFrame @TOC 一、简单了解requestAnimationFramerequestAnimationFrame,字面意思”请求动画帧”,估计该理解成”对动画的帧提出要求”.通过控制回调函数的调用时机,它对动画过程的控制也确实精确到了帧,这是我这样理解的原因; 三、requestAnimationFrame好在哪里1.可提升性能回调函数执行频率通常是每秒60次，为了提高性能和电池寿命，在大多数浏览器里，当requestAnimationFrame() 运行在后台标签页或者隐藏时，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命,而页面重新可视之后,动画会从上次停止的位置继续执行。 2.可避免屏幕刷新率影响这就会引出一个问题,就是”屏幕刷新率和程序生成的动画的更新频率如果不同会导致的后果”.setInterval的执行时间并不是确定的。在Javascript中， setInterval任务是一个异步操作会放进异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此setInterval 的实际执行时间会不太稳定。不同设备的屏幕刷新频率不同，而 setInterval只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。而这种不一致会导致掉帧卡顿,举个例子就是setInterval在第2s执行程序准备好了一张需要换上的新图,结果第2s屏幕恰好没刷新(那就没显示出这张新图),但是到下一次屏幕刷新的时候却成功更新了图像,那你看到的就是直接从第1帧蹦到了第3帧,第二帧图像没了. 与setInterval相比(如果收受到刷新率影响的话CSS3那俩方法应该也存在这种问题?)，requestAnimationFrame最大的优势是由系统来决定回调函数(在这里也就是setInterval())的执行时机。它会保证回调函数生效的时候刚好能赶上屏幕刷新，requestAnimationFrame会让回调函数的执行频率与屏幕刷新的间隔的出现频率同步。以此保证回调函数在屏幕每次刷新的间隔中被执行，来避免”恰好执行完赶上刷新间隔”,无法成功更新图像的情况. 3.防止回调函数异常调用(节流)requestAnimationFrame会让 [回调函数的执行频率] 与 [屏幕刷新的间隔的出现频率] 同步,然后在屏幕刷新间隔的空当让回调函数执行一次,不会执行多了,这样保证效果流畅的同时也节约执行函数的开销。 总结今天从一份Canvas特效源码里看到有这个属性,没见过,学习了一下,写了些东西,见解的比较粗略,您要是觉得有不好的地方可以在评论区与我交流:(这么长时间没写,这次写的倒还蛮找到点感觉,还举了个视网膜和函数的类比(这肯定让很多人一头雾水,哈).这个月一直在准备一场比较重要的考试,没有写博客…好在考试结束让我得以从这教科书的苦役中解放出来,继续完善我的博客和技术,这个月可以多花点时间在代码上了……","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"CSS 誤解記錄","date":"2021-08-12T17:50:38.000Z","path":"2021/08/13/CSS 誤解記錄/","text":"总结对3D效果的误解@TOC 一、perspective-origin一个可以支持你选择观看角度的属性.这个属性我是真没见过,查完回来又试验了几次,好歹是弄明白了什么意思: 你去过动物园吧,在栏杆外面看里面的动物? 这个属性就相当于你的脚,支持你改变自己在栏杆(屏幕)所在的这个无线延展的平面上的位置(包括纵向). 这个电脑屏幕就相当于你的可视区域(你就先当自己高度近视吧). 然后动物园里的栏杆你是不能翻过去的,一样这个属性也是只支持你在”栏杆”这个竖平面内改变可视区域的位置,栏杆平面内你左右挪上蹿下跳都没人管你,你就是别翻栏杆就得了. 然后笼子里的动物就在那,跨个批脸看你,你的元素们也是,你在这个平面上做的一切移动只能改变你观看它们的方位,它们一直就在那儿,不会受到影响.我上个图吧可能好理解一点: (因为画的很烂每次上个图都很羞耻)你的眼睛就嵌在平面1里,然后可以通过调整在平面1中的X,Y值来决定从哪个方位看这个立体空间. 我觉得它的值可以和perspective属性的值复合在一起写… 二、3D空间 transform属性的一些新理解以前的话这个属性在2D里还好,到3D空间基本就蒙圈了. 在给transform-style属性赋值preserve-3d之后,在页面纵深方向上的变化就可以合理一点而不是给人”2D空间中的宽高变化”这样的感觉了. 然后进了3D模式就分不清到底这transform是怎么个动法,实际上还是一样,只不过元素的坐标轴是基于自身的,自身位置或者方向发生变化后坐标轴的朝向自然也会跟着改变(这坐标轴总不能跟个指南针似的), 就比如你先把一个div给rotateY(围绕Y轴)了90度,那现在X轴就承担原本Z轴的工作:设定纵深值,而现在Z轴承担原本X轴负责的横向位置设定;我现在把4个div拼成一个方块,起初它们都是叠在一起的,但在加了rotate属性分离出来后你会发现各个轴控制的已经不是原本的方向. 123456&lt;div class=&quot;building1&quot;&gt; &lt;div class=&quot;one&quot;&gt;&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;&lt;/div&gt; &lt;div class=&quot;three&quot;&gt;&lt;/div&gt; &lt;div class=&quot;four&quot;&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233/* 这数值看着是挺离谱的 */ .building1 .one &#123; top: -2500px; height: 4500px; width: 2000px; transform: rotateY(90deg) translateX(2000px) translateZ(-4000px) translateY(700px); z-index: 2; &#125;/* 垂直屏幕的平面-右 */ .building1 .two &#123; top: -2500px; height: 5300px; width: 10000px; transform: translateX(-14200px) translateZ(-4000px)translateY(700px); z-index: 1; &#125;/* 平行屏幕的平面-远 */ .building1 .three &#123; top: -3500px; height: 6500px; width: 10000px; transform: translateX(-14200px) translateZ(-1370px) translateY(700px); z-index: 1; &#125;/* 平行屏幕的平面-近 */ .building1 .four &#123; top: -2500px; height: 4500px; width: 2000px; transform: translateX(2200px) translateZ(-12200px) translateY(700px); z-index: 2; &#125;/* 垂直屏幕的平面-左 */ 当然具体哪个轴在元素变化后会承担哪个另外轴的工作还得看你怎么个变化法,你要是rotateX围着X轴转那估计变的就是Y轴和Z轴了","tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"前端 文本自動換行","date":"2021-08-07T18:23:45.000Z","path":"2021/08/08/前端 文本自動換行/","text":"输入文本自动换行@TOC 解决方案看到有老哥说用textarea来写入文字可以换行, 没什么好办法了,眼下似乎这个”textarea”就是能做出目标效果的方法,硬着头皮用吧,下午就要交了. 二、其他方法实现文本换行1.div可编辑模式我今天才知道div有个属性叫contenteditable,这个属性的值为true时允许你在这个div上输入文字,这个文字也是夹在始末标签之间的字符;而且加上这个属性之后,输入的文字依然受到line-height和font系列属性的支持, 12345678910&lt;div contenteditable=&quot;true&quot; style=` line-height:100px; height:50px; width:100px; background-color:skyblue`&gt; wddw&lt;/div&gt; maxlength和placeholder属性无效;然后你可以看到目前是只能根据宽度width来决定是不是要换行,但是HTML有专门一套规定换行规则的属性,这在input里不能用,可这关我div什么事儿呢 ?|属性| 可用值 ||–|–|| word-break | break-all, normal, keep-all || word-wrap | break-word, normal | 属性 作用 word-break:break-all 不管怎么样,到了最大宽度就是要换行! word-break:normal 使用浏览器默认的换行规则 word-break:keep-all 只能在半角空格或连字符处换行。 word-wrap:break-word 检索英文单词,如果强制换行面临拆词,那么会保留完整词并在其后换行 word-wrap:normal 只在允许的断字点换行（浏览器保持默认处理）。","tags":[{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"}]},{"title":"解讀JavaScript閉包","date":"2021-08-04T14:26:44.000Z","path":"2021/08/04/解讀JS閉包/","text":"@TOC 二、让某些变量得以常驻内存我们需要将立即执行函数与闭包结合;我们都知道JavaScript是自带垃圾回收机制的,对于函数来说,在其执行完毕后会被垃圾回收机制回收来进行内存释放,函数内部的局部对象(各种变量之类)也会被连同销毁使内存中仅仅保存全局作用域. 1.原理前言说到闭包函数就是一个嵌套在父函数里面并且有使用父函数变量的子函数, 闭包函数的执行必定依赖于父函数提供的数据,但要是调用闭包函数时父函数已经被销毁,闭包函数怎么执行呢?没法执行,因为闭包函数所依赖的变量也都被销毁,总不能因为要执行闭包函数再把父函数提出来,不太合理; 所以不能就这么回收掉,但是保存整个父函数又有点离谱,所以JavaScript垃圾回收机制只会保存闭包函数在父函数中所依赖到的变量这些被保存起来的变量不会被内存回收器回收,直到确认子函数不会再被调用(子函数被删除或者失去指针)为止; 类比一下,如果你学过webpack的话,应该会知道webpack在打包一个文件的时候会把这个文件依赖的所有文件一起打包,就是为了防止使用的时候出问题,垃圾回收机制是在删减的时候留下需要的,weboack是在打包的时候加上需要的. 2.Why 立即执行函数?我想探讨一下为什么推荐用立即执行函数来配合闭包进行变量保存…一开始我猜为了在闭包函数保存完需要的变量后父函数能被及时回收释放内存,才采用了匿名立即执行函数来作为闭包函数的父函数.因为立即执行函数自我回调执行完成后会被立即销毁回收,用一次就释放,节约内存(但因为销毁快,外界无法引用其内部的变量)后来看到了一个例子,作者将使用了立即执行函数的闭包和没有使用立即执行函数的闭包进行了比较,让我改变了想法: 12345678910111213141516//例1,这个例子中没有使用立即执行函数;function createFunction() &#123; var Array = []; for( var i = 0; i&lt;10; i++) &#123; //将函数赋值给每个数组元素; Array[i] = function() &#123; return i; &#125;; &#125; return Array;&#125;var aa = createFunction();console.log(aa[0]()); //10console.log(aa[1]()); //10 由于作用域链的配置机制，因为每个函数的作用域链中保存的都是createFunctions()的活动对象,所以每个函数引用的都是活动对象中的同一个变量 i。(活动对象: 在JavaScript中，当一个函数被创建时最后一步便是活动对象推入作用域链,函数中访问一个变量时会从作用域链中搜索具有相应名字的变量,函数执行完后局部活动对象会被销毁,活动对象中包含了参数列表和arguments对象等属性. 活动对象包含变量对象所有的属性)当createFunctions() 函数执行结束返回后,变量 i 的值就已经固定为10，而每个函数保存的变量对象里的 i 都出自createFunctions()的活动对象,每个函数拿到的 i 都是出自同一个活动对象的,都一样,所以最后不论输出哪个数组元素得到的都是10.即说明了闭包中所保存的是整个活动对象，而不是某个具体的变量,这种机制并不是我们想要的,我们希望它能把每个变量单独保存下来,所以就有了能解决这个问题的,使用了立即执行函数的例子,即例2: 123456789101112131415161718192021function createFunction() &#123; var result = new Array(); for( var i = 0; i&lt;10; i++) &#123; result[i] = function(num) &#123; //每接收一个num就会创建新的一个函数作用域; return function() &#123; //在每个作用域的内部创建并返回一个返回num的闭包函数 return num; &#125;; &#125;(i); //变量i的当前值会作为实参赋值给上面的形参num; &#125; return result;&#125;//在外部使用函数内变量;var bb = createFunction();alert(bb[0]()); //0alert(bb[1]()); //1 闭包函数依赖到了外部立即执行函数的num,所以num会连同闭包函数被保存下来免于销毁,这样result[ ]中被赋值进去的每个函数都能返回一个自己的num,我们的目的就能达到了,完成这一目标的关键就是使用了立即执行函数. 这个闭包函数的父函数函数每接收一个num就会创建新的一个函数作用域(见例3),作用域中传入i后,变量i的当前值会作为实参赋值给上面的形参num,而在当前每个作用域的内部，又创建并返回了一个返回num的闭包函数。这样一来传入每个函数作用域中闭包函数的num就是不同的了.如此类推,被赋值进入result数组中的每个函数作用域都有一个自己num(其实是时num副本),可以返回各自不同的数值了. 12345678910for(var i = 0; i &lt; 5; i++) &#123; abc(i);&#125;;function abc(i) &#123; setTimeout(function() &#123; console.log(i); // 0 1 2 3 4 &#125;, 200); &#125;//这里就相当于创建了5个函数作用域; 可见立即执行函数在保存变量时泛用性比普通函数强; 三、让外部得以访问函数内变量外部访问函数内变量跟立即执行函数没什么必然关系,不使用立即执行函数也可以进行保存,上面说到的结合立即执行函数的写法只是针对某些特殊情况下无法依据需求保存变量的问题,我们不得不承认立即执行函数泛用性好一些. 在外部调用父函数即可拿到闭包函数内的变量; 四、立即执行函数刚学到的,单独开一篇感觉也没必要,正好这里用到了就写下来吧… 12345678//这两种写法是会报错的;(function() &#123;//函数体; &#125;)(); function() &#123;//函数体; &#125;(); JavaScript引擎先看到了你的”function”关键字,然后就开始以函数声明标准规范你后续的代码,最终JavaScript引擎发现你用一个小括号结束了你的函数,它觉得这是错的.我们不能否定它判定的规则,人家认为写了function就是要声明函数,那我们就不要上来直接写function了: 1234567var myFunction = function () &#123; /* 函数体 */ &#125;();var myObj = &#123; myFunction: function () &#123; /* 函数体 */ &#125; &#125;(); 让JavaScript引擎先看到小括号而不是function关键字,它就会觉得你在写函数表达式,也就判定为合理了;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"两个原生JS跨页面传值的小方法","date":"2021-07-28T12:25:39.000Z","path":"2021/07/28/两个原生JS跨页面传值的方法/","text":"@TOC 这会不会是今天写的最简单的一篇文…? 一、localStorage本地存储不能用sessionStorage,sessionStorage在当前会话关闭之后会进行销毁,存储的东西在下个页面全是undefined. 1234567891011//PageA var link = document.querySelector(&quot;a&quot;); var value1 //这个value1 /* localStorage.setItem(value1, &quot;1&quot;); var localS = localStorage.getItem(value1); console.log(localS); */ link.onclick = function () &#123; localStorage.setItem(value1, &quot;1&quot;); var localS = localStorage.getItem(value1); &#125; 当时提示我setItem应该传入两个参数,我觉得一个是key一个是value的话key应该不用提前声明,然后一跑,不行,这个value1还就得声明出来,哪怕你不赋值. 1234//pageB var value1 var localS = localStorage.getItem(value1); console.log(localS); 然后在B页面接收value1我就更是觉得”这个总可以直接拿来赋值进变量了吧?” 结果还是不行,还是得声明出value1才能拿到getItem()的value1.这个方法好在在第二个页面拿到数据之后不用进行太多处理,能比较方便的使用. 二、URL传值这个是我问了下同学他用的方法,感觉思维上更加合理一点, 123456789101112&lt;!-- pageA --&gt;&lt;body&gt; &lt;a href=&quot;#&quot;&gt;点击跳转页面&lt;/a&gt; &lt;script&gt; var link = document.querySelector(&quot;a&quot;); var value1 = &quot;value1&quot;; var value2 = &quot;value2&quot;; link.onclick = function jumpPage() &#123; window.open(&#x27;pageB.html?value1&amp;value2&#x27;); &#125; &lt;/script&gt;&lt;/body&gt; 主要就是URL拼接,其他也没什么好说的:window.open(“”) 1目标页面路径URL:&#x27;要打开的地址 + ? + 参数1 + &amp; + 参数2 + &amp; + 参数3 + ...&#x27; 在终点页面使用window.location.search()方法获取地址栏传过来的参数,得到”?参数1&amp;参数2&amp;参数3” 可以将其赋值给一个变量准备分离出传来的值:var receiveValue = window.location.search不要问号:receiveValue.substr(1) 123456789101112131415&lt;body&gt; &lt;p&gt;我是pageB&lt;/p&gt; &lt;script&gt; //输出都是有效的,可以解注释看看; var valueFromPageA = window.location.search; //console.log(&#x27;valueFromPageA: &#x27; + valueFromPageA); var aftercut = valueFromPageA.substr(1); //console.log(&#x27;aftercut: &#x27; + aftercut); var aftersplit = aftercut.split(&#x27;&amp;&#x27;); //console.log(&#x27;aftersplit: &#x27; + aftersplit + &#x27;类型: &#x27; + typeof (aftersplit)); var value1 = aftersplit[0]; var value2 = aftersplit[1]; //console.log(value1, value2); &lt;/script&gt;&lt;/body&gt; 比较糟糕的就是对于数据处理的步骤相比较来说会多一些.","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"Auto.js 全命令整理(一) 数据获取专题","date":"2021-07-28T09:35:25.000Z","path":"2021/07/28/Auto.js 全命令整理(一) 数据获取专题/","text":"应用信息获取 命令 目的 app.versionCode 获取当前所在应用的版本号. app.versionName 获取当前所在应用的版本名. app.getAppName(包名) 获取包名对应的应用名. app.getPackageName(应用名) 获取应用名对应的包名. currentPackage() 返回最近一次/当前运行的应用的包名. currentActivity() 返回最近一次/当前运行的应用名(Activity名). 设备信息获取 命令 目的 device.getIMEI() 返回设备IMEI国际移动设备识别码. device.getAndroidId() 返回设备的安卓ID,一个用16进制字符串表示的64位整数. device.getMacAddress() 返回设备的MAC地址. device.getBattery() 返回当前设备电量百分比. device.isCharging() 设备在充电返回true,否则返回false. device.getTotalMem() 返回当前设备内存总量,单位B(字节). device.getAvailMem() 返回当前设备可用内存. device.isScreenOn() 当前设备亮屏返回true,不亮返回false. 色彩信息获取 命令 目的 colors.toString(color) 返回RGB颜色值字符串(“#000”格式). colors.red(color) 返回RGB色彩模式R通道值数字. colors.green(color) 返回RGB色彩模式G通道值数字. colors.blue(color) 返回RGB色彩模式B通道值数字. colors.alpha(color) 返回Alpha通道值(透明度),范围0-255. colors.parseColor(colorStr) 返回色彩整数值字符串(#000格式). colors.isSimilar(color1, color2,[ 相似度临界值, 色彩匹配算法]) 相似度临界值:数值越小匹配越苛刻,要求的相似度要更高才能返回true; 色彩匹配算法:默认为diff,即两色彩RGB数值差的绝对值小于相似度临界值才能算成功;还有”rgb”,”rgb+”,”hs”三种其他方法. colors.equals(color1, color2) 比较传入的两个色彩值是否相等,返回布尔值. 末这个系列也开始连更了…目前规划出到第5章,把所有指令的说明提高一下可读性,然后分类整理出来,这样写的时候查起来会方便一些.话说Auto.js到底算是哪个类别的文章啊喂!","tags":[{"name":"Auto.js","slug":"Auto-js","permalink":"http://example.com/tags/Auto-js/"}]},{"title":"Auto.js 全命令整理(三) 输出专题","date":"2021-07-28T08:42:40.000Z","path":"2021/07/28/Auto.js 全命令整理(三) 输出专题/","text":"@TOC 一、路由元信息和beforeEach()用户点击某个模块会让URL发生变化,进而带动router执行切换页面的动作,那么只要阻止路由跳转或者让路由定向跳转就能实现阻止用户进入某些高权限页面.但在开始之前,我还要给您介绍两样东西: 1、路由元信息您可能没听说过这个词,不用着急;我不给您扯那些官方文案了,路由元信息在meta对象里配置,一个元信息针对一份路由,在其内部可以写键值对,即一对自定义字节和他们的值: 12345678&#123; path: &#x27;/userinfo&#x27;, name: &#x27;Userinfo&#x27;, //路由元信息meta; meta: &#123; istoken: true //自定义字节istoken,值为true; &#125;, 就是这样了,我不深说了,因为这里我们只是需要用meta对象内的键值对作为该路由记录是否需要执行beforeEach异步判断和需要执行判断时需要执行哪个beforeEach()的判别条件. 2、beforeEach()router.beforeEach() 用来规定一些进入页面的限制,比如不登陆无法进入你可以拿到一些有关用户账号权限的关键信息(比如meta信息),在里面做一些判断,然后利用beforeEach()的next()方法来告诉路由这波怎么说(是把尊敬的用户踹回去登录还是让他进页面); 1234567//注意这里传入的三个参数; router.beforeEach((to, from, next) =&gt; &#123; if (基于meta或其他关键信息进行的判断) &#123; //需要进行的操作; &#125; next()&#125;) 我想你该看到那上面传进去了三个参数……| 参数 | 作用 ||–|–|| to | 本次路由跳转的终点,锁定目标页面的路由对象 || from | 本次路由跳转的起点,锁定当前页面的路由对象 || next | 进行下一个钩子,类似”接下来要干的事”的意思吧,有点像then()? | 在index.js(就是写路由表的那个文件)里可以写这个beforeEach(),记得写在router创建后: 123456const router = new VueRouter(&#123; mode: &#x27;history&#x27;, base: process.env.BASE_URL, routes&#125;)//router.beforeEach()的位置 二、权限管理1、路由比较少的情况.一般来说用户登录后账号信息会从后端发来,然后你setItem()存储到本地(localStorage)放在token或者cookie,就可以拿getItem()获取来用了;我觉得你也可以简单粗暴一点把能访问1,2,3页面的用户添加到1,2,3页面的meta里,然后到时候他一登录,路由守卫把你meta里那几个人挨个儿过一遍,只要有个条件跟他匹配就行,不过要是你这网站用户很多,这一个个录人估计也是挺蛋疼的…… 下面就是针对多页面多路由的情况了,都需要遍历. 2、多路由-遍历to.matched推荐使用to.matched来进行遍历,to.matched数组中保存着匹配到的所有路由信息;我们来看看官方的说法吧:“一个路由匹配到的所有路由记录会暴露为 $route 对象或导航守卫中路由对象的 $route.matched 数组。因此,我们需要遍历 $route.matched来检查每份路由中的meta字段,来判断这个beforeEach该用于哪份路由.” 12345678910111213router.beforeEach((to, from, next) =&gt; &#123; //some检测to.match数组中的元素的meta里是否有requiresAuth; if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123; //some方法测试数组中是否有至少一个元素通过了判断。返回布尔值。 if (!auth.loggedIn()) &#123; next(&#123; path: &#x27;/login&#x27;, query: &#123; redirect: to.fullPath &#125; &#125;) &#125; else &#123; next() // 确保一定要调用 next(),否则钩子不会被resolve; &#125;&#125;) 遍历to.matched和上面官方文档说的”遍历 $route.matched”大概是在遍历同一个数组, $route是当前激活的路由,to是我们要去到的路由,在我们使用next()把路由阻拦回去之前,to所对应的路由是被激活的,所以我想这个to和 $route所对应的路由该是同一个路由的,那么to.match和 $route.match指的也应该是同一个数组.你要知道, Vue在匹配路由时会匹配到所有符合的路由,也就是说只要你path里出现了这段字符串,我就认为你有这段路由: 12path:&quot;/page1/page2/page3&quot;/* 匹配到的路由:/page1 &amp; /page1/page2 &amp; /page1/page2/page3 */ 这就有个好处,就是你遍历完正确的数组之后,可以把所有需要控制的页面全都提权,就是给那个URL最长的高级路由加meta字段,比如我不想让没注册的用户进入个人中心,我就直接给”个人中心/用户详情/文章列表/举报文章”(举个例子,别手滑给咱举报了)页面的路由加上meta,这样整个个人中心都进不来了.这样是最好,你也可以只给一级路由添加meta判断,一般用户都是一层一层的点进去看,但要是哪天遇见个离谱的老哥直接输二级路由的URL,那是可以直接进到你的二级路由的,虽然一级路由进不去.(啊当然你要是耐心的把每个把二级路由单独加判断…那当我没说咯).","tags":[{"name":"Auto.js","slug":"Auto-js","permalink":"http://example.com/tags/Auto-js/"}]},{"title":"Auto.js 全命令整理(二) 对应用命令专题","date":"2021-07-28T08:42:40.000Z","path":"2021/07/28/Auto.js 全命令整理(二) 对应用命令专题/","text":"@TOC 对应用命令主要用于确认屏幕显示的是否是正确的页面,so,并不多. 你会不会忘了怎么获取这些数据……?Auto.js 全命令整理(一) 数据获取专题 回顾-应用数据获取 命令 目的 app.versionCode 获取当前所在应用的版本号. app.versionName 获取当前所在应用的版本名. app.getAppName(包名) 获取包名对应的应用名. app.getPackageName(应用名) 获取应用名对应的包名. currentPackage() 返回最近一次/当前运行的应用的包名. currentActivity() 返回最近一次/当前运行的应用名(Activity名).","tags":[{"name":"Auto.js","slug":"Auto-js","permalink":"http://example.com/tags/Auto-js/"}]},{"title":"Vue组件传值(二) $emit子传父&事件触发","date":"2021-07-27T11:25:53.000Z","path":"2021/07/27/Vue组件传值(二) $emit子传父&事件触发/","text":"@TOC 一、$emit传递事件用来从子组件往父组件内传值,也能传事件,我们可以使用$ emit()让子组件得以触发父组件(子组件被哪个组件作为模板调用,哪个组件就是这个子组件的父组件;)中的事件函数.$ emit()被执行后会向父组件内发送自己括号内的参数,事件、值作参数都可以,值可以是data里的值,绑定到子组件的HTML上, 时刻变化. 但是在父组件内的子组件标签上要有能被$emit()发送来的事件触发的事件函数,即父组件内的子组件标签上要有针对[子组件发送来的事件]的监听,不然我们传过去一个事件也没什么用 我们通常不会直接放任子组件向父组件发送事件,你开局就发过去把事件函数触发了也没有什么意义.更多的使用方法是在子组件内定义一个点击事件(或者什么其他事件),能触发子组件内某个函数,然后这个子组件内的函数被触发后会使用$emit()向父组件内发送一个什么事件来触发父组件内某个已绑定的事件函数,这样就能做到在子组件内控制父组件事件函数的触发,就像这样: 123456789&lt;!-- 这里是子组件; --&gt;&lt;template&gt; &lt;div @click=&quot;bannerClick&quot;&gt; &lt;!-- !!!! --&gt; &lt;!-- ^点击触发bannerClick事件函数^ --&gt; &lt;div class=&quot;editbanner&quot;&gt; &lt;span&gt;&#123;&#123; left &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 1234567891011//这里是子组件export default &#123; props: [&quot;left&quot;], methods: &#123; bannerClick() &#123; //bannerClick事件函数触发; this.$emit(&quot;bannerClick&quot;);//!!!! //向父组件发送bannerClick事件; &#125;, &#125;,&#125;; 上面子组件已经发出了事件,那么父组件: 12345&lt;!-- 这里是父组件 --&gt; &lt;edit-banner left=&quot;昵称&quot; @bannerClick=&quot;show = true&quot;&gt; &lt;!-- ^bannerClick事件在此处被监听, 触发后使data()里的show属性值变为true,让edit-banner组件出现^ --&gt; &lt;/edit-banner&gt; 1234567891011121314//这里是父组件;import EditBanner from &quot;@/components/common/EditBanner&quot;;export default &#123; name: &quot;Edit&quot;, data() &#123; return &#123; show: false, //show属性,在bannerClick事件触发后变为true; &#125;; &#125;, components: &#123; EditBanner, &#125;,&#125; 就先这样,您要是有看不明白地方的可以在评论区指出,我会再次更新来完善. Vue传值决定出多出几期来记述各种传值方法,所以就把以前写的分类了,下面这部分是以前写的,可能理解上有些粗略,主要是围绕例子来的, 您要有兴趣就看看,不想看也无所谓啦. 总结“啊, 这么简单的一点事情这个博主怎么讲的这么麻烦啊?”确实,但我就是想讲的详细一点,毕竟我将来哪天说不定忘了也得回来看的,我要是回来查看到自己以前写的东西寥寥几笔带过那得多…这一系列关于传值的文章还会有的.我会在最近继续更新; 这是我个人的一些理解啦,如果您发现我的不足,我很高兴您能为我指出!","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"async&await异步请求处理办法","date":"2021-07-27T05:41:27.000Z","path":"2021/07/27/async&await异步请求处理办法/","text":"@TOC 因为await在没说完async的情况下不好进行,我打算先说async,当然,我会在不影响正常浏览的情况下在async部分里加入一些与await牵连的部分; 一、async1、async函数async函数:使用async关键字声明的函数,是AsyncFunction构造函数的实例， 内部可以使用await关键字。将async作为一个关键词放到函数前面,这个函数会变为一个async函数, 1234567//你可以看到我在函数前面加了&quot;async&quot;吧;async function asyncFunction1() &#123; return &#x27;An asyncFunction!&#x27;&#125;//那asyncFunction1现在就是一个async函数了; async函数调用后会返回一个Promise对象,调用async函数和调用普通函数在方法上没有区别,你可以直接: 12//我们顺带输出一下看看返回的Promise对象console.log(asyncFunction1()); 你可以看到Promise对象里有个”&lt; fulfilled&gt; “这代表Promise已经成功完成. async函数无法处理reject()的值,当async函数内部抛出错误时,Promise.reject()也会返回一个Promise对象,PromiseState会是”reject”,这里将会是”&lt; reject&gt;”,并且往往伴随报错信息. 2、回调async函数以获取结果async基于Promise,要想获取到async函数的执行结果,用Promise的方法,即then()或catch来为需要获取值的async函数注册回调. 12345678async function asyncFunction1() &#123; return &#x27;callback asyncFunction1&#x27;&#125;//使用then注册回调函数;asyncFunction1().then(res =&gt; &#123; console.log(res);&#125;) 如果没有为async函数注册回调函数,在async函数被调用并执行完成后…效果就只是完成了作为普通函数的功能,并且函数返回的值被封装成一个Promise对象;如果async函数注册了回调函数,那么async函数执行完成后,注册的回调函数会放入异步队列中等待执行. 二、await等待 .vt [书面语] await关键字只能放到async函数里面,后面可以加函数体或者任何表达式,但更多情况下会在后面放一个会返回Promise对象的表达式(比如一次需要时间响应并且还返回Promise对象的axios请求)来让await的等待变得有意义,因为产生Promise对象的操作一般都需要时间,如果是一个简单的操作一瞬间完成,那这个await岂不是等个寂寞… 程序执行到await的时候受await的影响,会停下进行等待(在这空挡跑去请求数据),等到await后面的表达式执行完成(请求的数据发过来)并且await拿到值后才会解除等待.这是一个异步操作,等待期间JavaScript引擎并不会止步于此,它会先执行下面的程序,等到async里的await表达式执行完把值拿出来了,它再回来拿值执行;比如你在async函数下面输出await的值,那必然是拿不到,因为这空当await还在等代着属于自己的值…下面是利用await等待一个axios请求的栗子: 12345678910const http = axios.create(&#123; baseURL: &quot;http://xxx.xx.xx.x:3000/api&quot;,&#125;) async asyncFunction2() &#123; //等待axios对象http使用post发起请求; const res = await this.http.post(&quot;/upload&quot;, formdata); //等到await的值被赋给res,说明await拿到了表达式的值; &#125;, 简洁的axios请求方法表(怎么又打广告):Vue 使用axios请求数据","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"Vue页面权限控制(一)","date":"2021-07-26T12:50:17.000Z","path":"2021/07/26/Vue页面权限控制/","text":"@TOC 一、路由元信息和beforeEach()用户点击某个模块会让URL发生变化,进而带动router执行切换页面的动作,那么只要阻止路由跳转或者让路由定向跳转就能实现阻止用户进入某些高权限页面.但在开始之前,我还要给您介绍两样东西: 1、路由元信息您可能没听说过这个词,不用着急;我不给您扯那些官方文案了,路由元信息在meta对象里配置,一个元信息针对一份路由,在其内部可以写键值对,即一对自定义字节和他们的值: 12345678&#123; path: &#x27;/userinfo&#x27;, name: &#x27;Userinfo&#x27;, //路由元信息meta; meta: &#123; istoken: true //自定义字节istoken,值为true; &#125;, 就是这样了,我不深说了,因为这里我们只是需要用meta对象内的键值对作为该路由记录是否需要执行beforeEach异步判断和需要执行判断时需要执行哪个beforeEach()的判别条件. 2、beforeEach()router.beforeEach() 用来规定一些进入页面的限制,比如不登陆无法进入你可以拿到一些有关用户账号权限的关键信息(比如meta信息),在里面做一些判断,然后利用beforeEach()的next()方法来告诉路由这波怎么说(是把尊敬的用户踹回去登录还是让他进页面); 1234567//注意这里传入的三个参数; router.beforeEach((to, from, next) =&gt; &#123; if (基于meta或其他关键信息进行的判断) &#123; //需要进行的操作; &#125; next()&#125;) 我想你该看到那上面传进去了三个参数……| 参数 | 作用 ||–|–|| to | 本次路由跳转的终点,锁定目标页面的路由对象 || from | 本次路由跳转的起点,锁定当前页面的路由对象 || next | 进行下一个钩子,类似”接下来要干的事”的意思吧,有点像then()? | 在index.js(就是写路由表的那个文件)里可以写这个beforeEach(),记得写在router创建后: 123456const router = new VueRouter(&#123; mode: &#x27;history&#x27;, base: process.env.BASE_URL, routes&#125;)//router.beforeEach()的位置 二、权限管理1、路由比较少的情况.一般来说用户登录后账号信息会从后端发来,然后你setItem()存储到本地(localStorage)放在token或者cookie,就可以拿getItem()获取来用了;我觉得你也可以简单粗暴一点把能访问1,2,3页面的用户添加到1,2,3页面的meta里,然后到时候他一登录,路由守卫把你meta里那几个人挨个儿过一遍,只要有个条件跟他匹配就行,不过要是你这网站用户很多,这一个个录人估计也是挺蛋疼的…… 下面就是针对多页面多路由的情况了,都需要遍历. 2、多路由-遍历to.matched推荐使用to.matched来进行遍历,to.matched数组中保存着匹配到的所有路由信息;我们来看看官方的说法吧:“一个路由匹配到的所有路由记录会暴露为 $route 对象或导航守卫中路由对象的 $route.matched 数组。因此,我们需要遍历 $route.matched来检查每份路由中的meta字段,来判断这个beforeEach该用于哪份路由.” 12345678910111213router.beforeEach((to, from, next) =&gt; &#123; //some检测to.match数组中的元素的meta里是否有requiresAuth; if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123; //some方法测试数组中是否有至少一个元素通过了判断。返回布尔值。 if (!auth.loggedIn()) &#123; next(&#123; path: &#x27;/login&#x27;, query: &#123; redirect: to.fullPath &#125; &#125;) &#125; else &#123; next() // 确保一定要调用 next(),否则钩子不会被resolve; &#125;&#125;) 遍历to.matched和上面官方文档说的”遍历 $route.matched”大概是在遍历同一个数组, $route是当前激活的路由,to是我们要去到的路由,在我们使用next()把路由阻拦回去之前,to所对应的路由是被激活的,所以我想这个to和 $route所对应的路由该是同一个路由的,那么to.match和 $route.match指的也应该是同一个数组.你要知道, Vue在匹配路由时会匹配到所有符合的路由,也就是说只要你path里出现了这段字符串,我就认为你有这段路由: 12path:&quot;/page1/page2/page3&quot;/* 匹配到的路由:/page1 &amp; /page1/page2 &amp; /page1/page2/page3 */ 这就有个好处,就是你遍历完正确的数组之后,可以把所有需要控制的页面全都提权,就是给那个URL最长的高级路由加meta字段,比如我不想让没注册的用户进入个人中心,我就直接给”个人中心/用户详情/文章列表/举报文章”(举个例子,别手滑给咱举报了)页面的路由加上meta,这样整个个人中心都进不来了.这样是最好,你也可以只给一级路由添加meta判断,一般用户都是一层一层的点进去看,但要是哪天遇见个离谱的老哥直接输二级路由的URL,那是可以直接进到你的二级路由的,虽然一级路由进不去.(啊当然你要是耐心的把每个把二级路由单独加判断…那当我没说咯).","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"Vue购物商城项目(二) 数据请求&使用","date":"2021-07-17T12:38:36.000Z","path":"2021/07/17/Vue购物商城项目(二)数据的请求&使用/","text":"前言1.这里面包含了大量的、我的个人理解与看法; 2.这是一个购物商城项目,目前阶段牵扯到路由, 插槽, axios数据请求, 数据存储与使用; 3.这篇只牵扯数据请求(axios), 数据使用; 4.现在这个项目已经全部完成; 总结第一个拿来起手的Vue项目,前面说到我现在已经做完了(眼: 明白了 手: 啥?)但还是打算吃的透一点,现在开始找其他项目做了,目前打算找一个基于element-ui的,届时我也会在博客把我的看法分享给大家:) 第三篇会是这个项目的最后一篇文了,打算把下拉加载(再请求)的部分和better-scroll的bug改进做完,您要是有兴趣,可以再来看看.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"Vue中使用axios请求数据","date":"2021-07-17T03:04:08.000Z","path":"2021/07/17/Vue中使用axios请求数据/","text":"@TOC 一、请求数据可以在methods里写上请求函数,然后用生命周期函数在不同时期调用: 我们该尽量避免在每个组件中单独请求这个组件需要的数据, 这不仅会造成项目对某一框架依赖性过大,框架改动时需要改动大量代码,各个组件分开进行的多次请求还会增大对服务器的压力;必然是要想办法减少请求次数的,就像宿舍里吃饭,每次总要出个打工人去买全宿舍的饭, 在Vue项目这个”大宿舍”里,这个”打工人”就是 request.js 了,它要一次买来全宿舍的饭(啊呸,请求来全部的数据),然后分给这个宿舍里的每个人(组件), axios进行的是网络请求,这里用来盛放 request.js 的文件夹就姑且叫做”network”吧 .接下来我会在request.js里完成整个项目的数据请求; 1.请求方法 请求方法 说明 axios({config}) 最原始的axios请求方式,axios(配置对象) axios.get(url , {config}) 需要传入URL和配置对象 axios.delete(url , {config}) 需要传入URL和配置对象 axios.head(url , {config}) 需要传入URL和配置对象 axios.post(url , {data}, {config}) 需要传入URL和作为请求主体的data对象,和配置对象 axios.put(url , {data}, {config}) 需要传入URL和作为请求主体的data对象,和配置对象 axios.patch(url , {data}, {config}) 需要传入URL和作为请求主体的data对象,和配置对象 关于config配置对象的配置方法,我会在下文说到; 2.config对象的配置方法 配置项 作用 url 字符串,指明请求的目标,向何处发送请求 method 字符串,设置请求的方法,默认get baseurl 字符串,设置url的基础结构,该项设置后,baseurl会自动与url进行拼接,形成完整的url,这个baseurl最好是设置为多个请求url相同的前段部分,如此可以共用baseurl transformRequest 数组型值,只能用在put, post,patch方法中,在向服务器发送数据前在此处进行再处理,你可以在这个数组里写处理数据的函数,但别忘了return. transformResponse 数组型值,可以对服务器返回的东西先做一些处理，这个操作允许在响应之前完成,你同样可以在这个数组里写函数,同样别忘记return. headers 对象型值,有验证作用, 在某些项目中需要进行身份校验,要求在请求头信息中加入特殊的标识，以此检验是否满足请求条件 params 简化传递url参数的流程,添加到url的请求字符串中无法传递json格式的数据,主要用于get中 data 对象型(会被转换为字符串) / 字符串型, 添加到请求体（body）中,支持json格式的数据,主要用于post中 paramsSerializer 函数型值,对请求的参数序列化, 它可以处理用于传递的数据, 比如您可以用这个属性来把params里的数组转化为字符串,因为函数中需要使用qs.stringify(), 使用前需要引入序列化库qs(即import qs from ‘qs’) timeout 设置等待时长,请求超时会取消请求 withCredentials 布尔值, 设置跨域请求时coockie的携带,默认false adapter 设置对请求的识别，是发送ajax请求还是在js里发送http请求 auth 对象, 设置对请求的基础信息验证 responseType 对响应器结果的格式做设置,默认json responseEncoding 响应结果编码格式,默认utf8 xsrfCookieName 跨域请求标识，对coockie名字做设置 xsrfHeaderName 对头信息做安全设置，保证请求来自正确的客户端 onUploadProgress 上传回调,值可以为自定义函数 onDownloadProgress 下载回调,值可以为自定义函数 maxContentLength 设置http响应体的最大尺寸，单位bit maxBodyLength 请求体的最大尺寸，单位bit validateStatus 对响应结果的成功码做相关设置 maxRedirects 最大跳转次数 socketPath 设定socketPath位置，作用：数据转发 proxy 设置代理 cancelToken 对ajax的请求做取消设置 decompress 解压响应结果 3.发送并发请求axios.all(): 用于同时发送多个请求;axios.spread(): 用于分离数组中得到的数据; 123456789101112131415161718192021222324//发送两个axios请求,就用最原始的axios()吧;axios.all([axios(&#123; url: &#x27;http://123.207.32.32:8000/home/data?type=sell&amp;page=3&#x27;&#125;), axios(&#123; url: &#x27;http://123.207.32.32:8000/home/data&#x27;, params: &#123; type: &#x27;paper&#x27;, page: 4 &#125;&#125;)])axios.all([axios(&#123; url: &#x27;http://123.207.32.32:6000/home/data?type=sell&amp;page=3&#x27;&#125;), axios(&#123; url: &#x27;http://123.207.32.32:6000/home/data&#x27;, params: &#123; type: &#x27;paper&#x27;, page: 4 &#125;&#125;)]).then(axios.spread((response1, response2) =&gt; &#123; //axios.spread将返回的数组展开,不加的话会返回一个包含两个对象的数组; console.log(response1); console.log(response2);&#125;)) 您可以不把all()与请求函数写在一起, 如果多个请求函数需要加入一次并发请求,您只需要在同一个axios.all()内调用他们即可;如果不写在request.js里,您可以把请求写在methods里,然后利用生命周期函数在不同时刻调用; 12345//在mounted生命周期执行axiosRequest1请求和axiosRequest2请求; mounted:function()&#123; axios.all([axiosRequest1(), axiosRequest2()]) .then() &#125; 二、数据的使用上表的语句书写正确仅能完成数据的请求,数据还是会在方法执行完后被连同方法一起销毁,如果想要应用这些数据,也就是分发数据给各个组件,需要先把数据稳定的保存下来,这里作为示例,就先保存到变量”response”里吧: 123456789101112//保存get请求的数据;axios.get(&quot;url&quot;, &#123; params: &#123; type: &#x27;sell&#x27;, page: 4 &#125;&#125;).then(response =&gt; &#123; console.log(response);&#125;).catch(error =&gt; &#123; console.log(error);&#125;) 123456789101112//保存post请求的数据;axios.post(&quot;url&quot;,&#123; id:356, name:&quot;bx&quot;,&#125;,&#123; timeout:2000&#125;).then(response =&gt; &#123; console.log(response);&#125;).catch(error =&gt; &#123; console.log(error);&#125;) 我觉得你也看出来了吧…与前面表中部分并没有差别,唯一多出来的是利用then()把请求结果拿出来;Pending等待状态: 正进行网络请求或定时器未到时等,正在请求;Fulfill满足状态: 调用resolve()进行请求完毕后的链式程序,调用then(),返回的数据接收到then()里;reject失败/拒绝状态: 未请求到数据,主动回调reject(),执行catch(); 为何使用该种模式来拿取数据 :普通方法进行的异步网络请求,看着时常是杂乱无章,可读性差不是它的唯一缺点,在请求非常复杂时,容易出现回调地狱;请求方法(即axios系列方法)请求到数据后会把数据传到自身内部进行处理,这是代码量大时可读性差的原因之一,而且如果中途某次请求的完成需要上次请求的结果,比较复杂的情况下会出现回调地狱 . Promise异步编程解决方案:依照Promise的思想,它是不希望我们这么干的,其希望把拿回的数据在专门的地方被处理,也就是在then()中,而不是拿到后夹在各个请求之间直接原地处理.Promise中的resolve()会接收传入请求方法中的请求结果传给then(),然后立即执行then(data),在then()中进行数据处理. 123456789101112131415161718192021//每次setTimeout是一次请求吧,您当它是&quot;请求()&quot;也行;new Promise((resolve, reject) =&gt; &#123;//第一次请求 setTimeout(() =&gt; &#123; resolve() //一旦调用了resolve(),本次Promise的最后会立即调用then() &#125;, 1000)&#125;).then(() =&gt; &#123;//处理第一次请求结果,输出一下,就当是处理结果吧... console.log(HelloWorld); return new Promise((resolve, reject) =&gt; &#123;//第二次请求; setTimeout(() =&gt; &#123; resolve() &#125;, 1000) &#125;)&#125;).then(() =&gt; &#123;//处理第二次请求结果; console.log(HelloVue); console.log(HelloVue);&#125;)","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"Vue-cli4 alias配置","date":"2021-07-03T07:23:26.000Z","path":"2021/07/03/Vue-cli4 alias配置/","text":"配置别名首先依据如下路径找到base.js文件; 1node_modules&gt;@vue&gt;cli-service&gt;lib&gt;config&gt;base.js 然后找到如下: 123456789101112131415161718webpackConfig.resolve // This plugin can be removed once we switch to Webpack 6 .plugin(&#x27;pnp&#x27;) .use(&#123; ...require(&#x27;pnp-webpack-plugin&#x27;) &#125;) .end() .extensions .merge([&#x27;.mjs&#x27;, &#x27;.js&#x27;, &#x27;.jsx&#x27;, &#x27;.vue&#x27;, &#x27;.json&#x27;, &#x27;.wasm&#x27;]) .end() .modules .add(&#x27;node_modules&#x27;) .add(api.resolve(&#x27;node_modules&#x27;)) .add(resolveLocal(&#x27;node_modules&#x27;)) .end() .alias//alias:别名,在此处依据格式配置别名; .set(&#x27;@&#x27;, api.resolve(&#x27;src&#x27;)) .set(&#x27;assets&#x27;, api.resolve(&#x27;src/assets&#x27;)) .set(&#x27;components&#x27;, api.resolve(&#x27;src/components&#x27;)) .set(&#x27;views&#x27;, api.resolve(&#x27;src/views&#x27;))","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"Vue购物商城项目——TabBar制作","date":"2021-07-03T03:13:30.000Z","path":"2021/07/03/Vue3购物商城项目——TabBar/","text":"一、Cli4生成项目略略略;使用Vue-cli4.5x快速搭建项目头铁,全用最新版了;| 插件 | 版本 ||–|–|| Vue | ^3.0.0 || vue-router | ^4.0.0-0 || axios | ^0.21.1 || css-loader | ^3.6.0 || style-loader | ^1.1.3 |文章阶段性同步, 插件部分目前就用到了这些; 二、路由配置我想了一下,还是决定返回来先把路由写上,因为TabBarItem需要用到路由来判断高亮显示与否; 12345678910111213141516171819202122232425262728293031323334353637//这是在index.js里;import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;//cli4真的就只需要引入这俩了;const routes = [ &#123; path: &#x27;/&#x27;, name: &#x27;home&#x27;, component: () =&gt; import(&#x27;../views/home/Home.vue&#x27;) &#125;, &#123; path: &#x27;/classify&#x27;, name: &#x27;classify&#x27;, component: () =&gt; import(&#x27;../views/classify/classify.vue&#x27;) &#125;, &#123; path: &#x27;/shoppingcar&#x27;, name: &#x27;shoppingcar&#x27;, component: () =&gt; import(&#x27;../views/shoppingcar/shoppingcar.vue&#x27;) &#125;, &#123; path: &#x27;/my&#x27;, name: &#x27;my&#x27;, component: () =&gt; import(&#x27;../views/my/my.vue&#x27;) &#125;]/*我们一共有四个页面,需要四条路由; */const router = createRouter(&#123; history: createWebHistory(process.env.BASE_URL), routes /* 把路由表(就是上面的那个装着对象的数组)放在这里, 在下面一起导出,供组件使用 */&#125;)export default router/* 导出路由表 */ Cli4.x路由配置详解 三、tabBar制作我想你可能见过那种固定定位,不会随着页面滚动的底部横条?这部分共包括三个组件; TabBar TabBarItem MainTabBar TabBar和TabBarItem有插槽关系,TabBar有一个插槽, 在MainTabBar处可以传入所有的(4个)TabBarItem; 每个TabBarItem有三个插槽,在MainTabBar处可以传入各个TabBarItem的内容; 我们先看TabBar和TabBarItem, 封装完这两个我们才能封装MainTabBar; 2.TabBarItem组件考虑到我难以把说明对应到代码位置,下面的说明基本都写在代码注释里,如果你想要看某段代码的说明,请在这段代码下方寻找; template标签用来写组件模板,在Cli4里,根元素不再只能有唯一一个,你可以在里面写多个根元素(不过下面这个还是只写了一个tab-bar-item); 1234567891011121314151617181920212223242526272829//这是在src/components/common/tabbar/TabBarItem.vue里;&lt;template&gt; &lt;div class=&quot;tab-bar-item&quot;&gt; &lt;div&gt;&lt;slot name=&quot;item-icon&quot;&gt;&lt;/slot&gt;&lt;/div&gt; &lt;div&gt;&lt;slot name=&quot;item-icon-active&quot;&gt;&lt;/slot&gt;&lt;/div&gt; &lt;div&gt;&lt;slot name=&quot;item-text&quot;&gt;&lt;/slot&gt;&lt;/div&gt; /* 这里全部采用ver2.6.0后的具名插槽, 防止传入混乱导致的无法传入; */ &lt;/div&gt;&lt;/template&gt; /* 我们的每个TabBarItem都由三个插槽组成: item-icon需要被传入未点击时的图标 item-icon-active需要被传入点击时的高亮图标 item-text需要被传入一个放入了文本的div; */&lt;script&gt;/* 为了不影响浏览,控制未触发图标和高亮图标切换的代码写在下面了 */&lt;/script&gt;&lt;style scoped&gt;.tab-bar-item &#123; flex: 1; margin-left: 23px; text-align: center;&#125;&lt;/style&gt; 我们现在来完成TabBarItem图标点击高亮的功能,虽然图标还没传入,看不到效果; 四、MainTabBar组件不打算在项目里引入TabBar和TabBarItem就封装的彻底一点吧，到时候只引入MainTabBar就好了； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//这是在src/components/content/mainTabBar/MainTabBar.vue里;//这里的~assets是因为定义了别名,如果没有定义别名还是要中规中矩写...//四个对tabbaritem的插槽传入,因为结构都相同,注释只在前两个;&lt;template&gt; &lt;tab-bar&gt; /*从此处向下,到&lt;/tab-bar&gt;截止,都是给TabBar的插槽传的内容 */ &lt;router-link to=&quot;/&quot;&gt; &lt;tab-bar-item activeColor=&quot;rgba(4, 39, 238, 0.856)&quot;&gt; /* tab-bar-item:从此处开始到首个&lt;/tab-bar-item&gt;, 是给第一个tabbaritem的插槽传入的内容; */ /* activeColor:其值传给TabBarItem组件中的props, 必须是一个颜色值; */ &lt;template v-slot:item-icon&gt; &lt;img src=&quot;~assets/img/icon/Brightness.png&quot; /&gt; &lt;/template&gt; &lt;template v-slot:item-icon-active&gt; &lt;img src=&quot;~assets/img/icon/Brightness2.png&quot; /&gt; &lt;/template&gt; &lt;template v-slot:item-text&gt; &lt;div&gt;首页&lt;/div&gt; &lt;/template&gt; &lt;/tab-bar-item&gt; &lt;/router-link&gt; /* 我们需要分别给四个tabbaritem插槽传内容 */ &lt;router-link to=&quot;/classify&quot;&gt; &lt;tab-bar-item activeColor=&quot;rgba(4, 39, 238, 0.856)&quot;&gt; &lt;template v-slot:item-icon&gt; &lt;img src=&quot;~assets/img/icon/Gear.png&quot; /&gt; &lt;/template&gt; /* 还记得在做TabBarItem时的具名插槽吗? 你可以在这里规定这份template里的html要传到哪个插槽了, 嗯,用v-slot对应name属性; */ &lt;template v-slot:item-icon-active&gt; &lt;img src=&quot;~assets/img/icon/Gear2.png&quot; /&gt; &lt;/template&gt; &lt;template v-slot:item-text&gt; &lt;div&gt;分类&lt;/div&gt; &lt;/template&gt; &lt;/tab-bar-item&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/shoppingcar&quot;&gt; &lt;tab-bar-item activeColor=&quot;rgba(4, 39, 238, 0.856)&quot;&gt; &lt;template v-slot:item-icon&gt; &lt;img src=&quot;~assets/img/icon/unlock.png&quot; /&gt; &lt;/template&gt; &lt;template v-slot:item-icon-active&gt; &lt;img src=&quot;~assets/img/icon/Lock.png&quot; /&gt; &lt;/template&gt; &lt;template v-slot:item-text&gt; &lt;div&gt;购物车&lt;/div&gt; &lt;/template&gt; &lt;/tab-bar-item&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/my&quot;&gt; &lt;tab-bar-item activeColor=&quot;rgba(4, 39, 238, 0.856)&quot;&gt; &lt;template v-slot:item-icon&gt; &lt;img src=&quot;~assets/img/icon/Task.png&quot; /&gt; &lt;/template&gt; &lt;template v-slot:item-icon-active&gt; &lt;img src=&quot;~assets/img/icon/Task2.png&quot; /&gt; &lt;/template&gt; &lt;template v-slot:item-text&gt; &lt;div&gt;我的&lt;/div&gt; &lt;/template&gt; &lt;/tab-bar-item&gt; &lt;/router-link&gt; &lt;/tab-bar&gt; &lt;router-view /&gt; /* 把router-view写在template里, 不然就等着tabbar跑顶部去吧... */&lt;/template&gt;&lt;script&gt;import TabBar from &quot;components/common/tabbar/TabBar&quot;;import TabBarItem from &quot;components/common/tabbar/TabBarItem&quot;;export default &#123; name: &quot;App&quot;, components: &#123; TabBar, TabBarItem, &#125;,&#125;; /* 引入TabBar和TabBarItem,注册一下以备使用; */&lt;/script&gt;&lt;style&gt;/* 你可以在这里写文字的样式,router-link标签默认会被渲染成&lt;a&gt;标签; */&lt;/style&gt; 五、Icon路径 总结艰难的考试周ing…昨天收到”好消息”,我要留校培训到30号(痛苦面具) X目","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"Vue-cli4 对路由配置的理解","date":"2021-06-19T12:11:45.000Z","path":"2021/06/19/Vue-cli4 对路由配置的理解/","text":"二、路由懒加载技术把不同的路由对应的组件分离,仅当某路由被触发时才会加载对应组件,会更加高效,并且第三方 &amp; 底层支撑 &amp; 公共App 除外, 其他的Vue页面组件都在服务器,随用随请求,确保对页面的影响最小. 其实就是改变一下router/index.js里对各个组件的引入方法啦……通过箭头函数的方法进行. 123456789101112131415161718192021const routes = [ &#123; path: &#x27;/about&#x27;, name: &#x27;About&#x27;, component: () =&gt; import(&#x27;../views/About.vue&#x27;) //直接在这里引入了About并且赋值给了component; &#125;, &#123; path: &#x27;/news&#x27;, name: &quot;News&quot;, component: () =&gt; import(&quot;../views/News.vue&quot;) //直接在这里引入了About并且赋值给了component; &#125;, &#123; path: &#x27;/login&#x27;, name: &#x27;Login&#x27;, component: () =&gt; import(&#x27;../views/Login.vue&#x27;) //直接在这里引入了About并且赋值给了component; &#125;,] 四、动态路由很多时候页面需要跳转到哪里是不能由我们写程序的来确定的,这就需要程序按照需求去自己决定,让路由得以动态改变. 1.动态路由配置说简单些,我们不把[to需要增加的URL]和[path判定跳转的URL]写死就好了,把URL里需要经常变化的部分,利用v-bind与export default中的data数据互通起来,让URL跟随数据变动. 12345678910111213141516//这是在router/index.jsimport &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;;const routes = [ &#123; path: &#x27;/&#x27;, name: &#x27;Home&#x27;, component: () =&gt; import(&#x27;../views/Home.vue&#x27;), &#125;, &#123; //我们在此处也不要把path的值写死; path: &#x27;/user/:userId&#x27;, name: &#x27;User&#x27;, component: () =&gt; import(&#x27;../views/User.vue&#x27;), &#125;]; 1234567891011121314151617181920212223&lt;!-- 这是在App.vue里 --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; | &lt;!-- 在此处使用v-bind将userId数据调用; --&gt; &lt;!-- 将/user/作为字符串拼接给userId --&gt; &lt;router-link v-bind:to=&quot;&#x27;/user/&#x27; + userId&quot;&gt;用户&lt;/router-link&gt; &lt;/div&gt; &lt;router-view /&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;app&quot;, data() &#123; return &#123; //在此处设定userId的数据为baixia; userId: &quot;baixia&quot;, &#125;; &#125;,&#125;;&lt;/script&gt; 来看下效果:接下来点击用户:URL成功拼接了了data里的数据UserId,即baixia. 2.动态路由传参动态路由也是Vue传递数据的方式之一,利用$route来进行Vue页面组件(即vue文件)间的通信.先来认识两个变量: $router: index.js末尾利用createRouter创建的路由对象 $route: 当前正处于活跃状态下的路由对象,其中有一个params属性,全称parameters,利用它,可以取到我们URL里使用v-bind传的值. 比如User.vue需要获取App.vue的data中的userId数据: 1234567891011121314151617&lt;!-- 在App.vue中(发方) --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link v-bind:to=&quot;&#x27;/user/&#x27; + userId&quot;&gt;用户&lt;/router-link&gt; &lt;/div&gt; &lt;router-view /&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;app&quot;, data() &#123; return &#123; userId: &quot;baixia&quot;, &#125;; &#125;,&#125;;&lt;/script&gt; 123456789101112//在user.vue中(收方)export default &#123; name:&quot;user&quot;, computed: &#123; userId() &#123; return this.$router.params.userId//将this.$router.param.userId的值,//即App.vue的router-link里传入的userId返回,//以作为计算属性userID()的值 &#125; &#125;&#125; User.vue里为了获取用户信息而使用的params,其获取哪个属性依赖于index.js里的path,的如果path:’/user/:abc’,那么User.vue的&lt; script&gt;里应当为: 123456789export default &#123; name:&quot;user&quot;, computed: &#123; userId() &#123; //这里也应为获取abc属性; return this.$router.params.abc &#125; &#125;&#125;","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! node-sass@","date":"2021-06-17T15:30:27.000Z","path":"2021/06/17/npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! node-sass@/","text":"问题描述：使用npm安装node-sass时报错: 123456npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! node-sass@4.14.1 postinstallnpm ERR! Exit status 1npm ERR!npm ERR! Failed at the node-sass@4.14.1 postinstall script. 解决方案：这里修改成了了taobao的npm 1npm config set sass_binary_site=https://npm.taobao.org/mirrors/node-sass 重新安装,解决: 1npm install","tags":[{"name":"Bug","slug":"Bug","permalink":"http://example.com/tags/Bug/"}]},{"title":"Node Sass version 6.0.0 is incompatible with ^4.0.0.","date":"2021-06-17T15:20:08.000Z","path":"2021/06/17/Node Sass version 6.0.0 is incompatible with ^4.0.0./","text":"问题描述：安装node-sass后npm run serve提示:Node Sass version 6.0.0 is incompatible with ^4.0.0. 解决方案尝试下载更低版本的node-sass,卸载原来的node-sass,使用了Ver 4.14.1的node-sass,问题解决; 1npm uni node-sass -D 1npm i node-sass@4.14.1 -D","tags":[{"name":"Bug","slug":"Bug","permalink":"http://example.com/tags/Bug/"}]},{"title":"解读箭头函数this指向","date":"2021-05-29T07:07:14.000Z","path":"2021/05/29/解读箭头函数this指向/","text":"一、熟悉箭头函数箭头函数是ES6新增的语法,当准备把函数作为参数传递时,用箭头函数看起来会比较简洁,简洁,但是可读性略差(尤其是它被省略的根本不像个函数的时候). 1.传一个参数1234const 函数名 = 参数 =&gt; &#123; xxx函数体 xxx函数体&#125; 或 1234const 函数名 = (参数) =&gt; &#123; xxx函数体 xxx函数体&#125; 2.传多个参数1234const 函数名 = (参1,参2) =&gt; &#123;xxx函数体xxx函数体&#125; 总结","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"使用Vue-cli4.5.x快速搭建项目","date":"2021-05-29T05:51:12.000Z","path":"2021/05/29/使用vue-cli4.5.x快速搭建项目/","text":"我不太适应ESLint,我这里就不逞能了……最下的单元测试(unit Testing)和端到端测试(E to E Testing),有需求的话就开; 4.单项配置选中第一项””Choose Vue version来进行单项配置:是否为vue-router启用HTML5的history模式?这个推荐启用,会让你的url更加整洁好看,可读性更高;在SPA页面中,不少方法会依赖于HTML5的history模式; 好的,你打算把这次构建项目的配置沿用到今后嘛?这个你自己决定喽……选择是的话,下次在执行第一步时就会出现第四个选项,那就是你自定义的配置方法. 5.选择包管理工具会让你选择是用npm还是yarn,我这里没有显示直接用了npm ,奇奇怪怪;选自己想用的就好. 至此创建完成.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"is a Vue CLI 3 only command and you are using Vue CLI 2.9.6. You may...","date":"2021-05-24T14:48:38.000Z","path":"2021/05/24/is a Vue CLI 3 only command and you are using Vue CLI 2.9.6/","text":"项目场景：Vue-cli3执行生成脚手架,这个bug已解决; 原因分析：你可以忽略这部分直接看最下解决方案; 推测未成功安装,依据意见,以管理员权限运行cmd: 12345678910111213C:\\windows\\system32&gt;npm install -g @vue/clinpm WARN deprecated @hapi/joi@15.1.1: Switch to &#x27;npm install joi&#x27;npm WARN deprecated request@2.88.2: request has been deprecated, see https://github.com/request/request/issues/3142npm WARN deprecated @hapi/address@2.1.4: This version has been deprecated and is no longer supported or maintainednpm WARN deprecated @hapi/bourne@1.3.2: This version has been deprecated and is no longer supported or maintainednpm WARN deprecated @hapi/hoek@8.5.1: This version has been deprecated and is no longer supported or maintainednpm WARN deprecated @hapi/topo@3.1.6: This version has been deprecated and is no longer supported or maintainednpm WARN deprecated har-validator@5.1.5: this library is no longer supportednpm WARN deprecated resolve-url@0.2.1: https://github.com/lydell/resolve-url#deprecatednpm WARN deprecated urix@0.1.0: Please see https://github.com/lydell/urix#deprecatedD:\\toolkit\\node_global\\vue -&gt; D:\\toolkit\\node_global\\node_modules\\@vue\\cli\\bin\\vue.js+ @vue/cli@4.5.13updated 1 package in 56.355s 未报错; 再次执行vue create xxx,相同报错,未解决; 删除AppData的npm_cache文件,无效,删除后npm安装vuecli3开始报错npm ERR! code EPERM npm ERR! syscall unlink 已安装cnpm,推测为此导致的权限问题;尝试cnpm安装vuecli3,安装时抛出报告有不同: 1234567891011121314151617181920C:\\windows\\system32&gt;cnpm i @vue/cli -gDownloading @vue/cli to D:\\toolkit\\node_global\\node_modules\\@vue\\cli_tmpCopying D:\\toolkit\\node_global\\node_modules\\@vue\\cli_tmp\\_@vue_cli@4.5.13@@vue\\cli to D:\\toolkit\\node_global\\node_modules\\@vue\\cliInstalling @vue/cli&#x27;s dependencies to D:\\toolkit\\node_global\\node_modules\\@vue\\cli/node_modules[1/35] @types/ejs@^2.7.0 installed at node_modules\\_@types_ejs@2.7.0@@types\\ejs[2/35] commander@^2.20.0 installed at node_modules\\_commander@2.20.3@commander[3/35] deepmerge@^4.2.2 installed at node_modules\\_deepmerge@4.2.2@deepmerge[4/35] @vue/cli-ui-addon-widgets@^4.5.13 installed at node_modules\\_@vue_cli-ui-addon-widgets@4.5.13@@vue\\cli-ui-addon-widgets[5/35] debug@^4.1.0 installed at node_modules\\_debug@4.3.1@debug[6/35] @vue/cli-ui-addon-webpack@^4.5.13 installed at node_modules\\_@vue_cli-ui-addon-webpack@4.5.13@@vue\\cli-ui-addon-webpack[7/35] ejs@^2.7.1 installed at node_modules\\_ejs@2.7.4@ejs[8/35] envinfo@^7.5.1 installed at node_modules\\_envinfo@7.8.1@envinfo[9/35] cmd-shim@^3.0.3 installed at node_modules\\_cmd-shim@3.0.3@cmd-shim[10/35] ini@^1.3.5 installed at node_modules\\_ini@1.3.8@ini[11/35] boxen@^4.1.0 installed at node_modules\\_boxen@4.2.0@boxen[12/35] isbinaryfile@^4.0.6 installed at node_modules\\_isbinaryfile@4.0.8@isbinaryfile[13/35] fs-extra@^7.0.1 installed at node_modules\\_fs-extra@7.0.1@fs-extra[14/35] javascript-stringify@^1.6.0 installed at node_modules\\_javascript-stringify@1.6.0@javascript-stringify[15/35] import-global@^0.1.0 installed at node_modules\\_import-global@0.1.0@import-global//余部略; 未报错; 重启VSCode,尝试执行vue create xxx;不再报错npm ERR! code EPERM npm ERR! syscall unlink; 失败,相同报错s a Vue CLI 3 only command and you are using Vue CLI 2.9.6……; 检查vue -V,返回2.9.6,卸载无效,新版本安装未报错,推测覆盖失败;删除C:/用户/hp/.npmrc文件执行寻找:C:\\Users\\hp&gt;where vueC:\\Users\\hp\\AppData\\Roaming\\npm\\vueC:\\Users\\hp\\AppData\\Roaming\\npm\\vue.cmd删除上二文件; 再次执行全局卸载npm uninstall vue-cli -g,出现长时卡顿,等待from21:58;卡顿;等待to22:05:蚌埠住了,取消执行; 再执行from22:07;till22:10:fetchMetadata: sill resolveWithNewModule &#109;&#105;&#109;&#x65;&#45;&#x64;&#x62;&#x40;&#49;&#46;&#x34;&#55;&#46;&#x30; checking installable status;尝试还原npm-cache文件夹至原位置,还原开始10s+后卸载执行完成,还原未完成,取消还原;推测checking installable status检索花费长时,非因缺失npm-cache内部文件; 卸载执行完毕,vue -V检查版本号;vue -V未检索到版本号,推测成功卸载; 开始尝试第5次执行全局安装vue-cli3.0;执行npm install -g @vue/cli from22:16;till22:20,等待长时卡顿中:fetchMetadata: sill resolveWithNewModule &#97;&#110;&#x73;&#105;&#x2d;&#x72;&#x65;&#x67;&#x65;&#120;&#64;&#53;&#46;&#48;&#x2e;&#48; checking installable status;to22:28 卡顿,取消执行; 再执行cnpm install @vue/cli -g;完成at22:30;执行vue -V:@vue/cli 4.5.13;终止; VSCode重启执行vue create testvuecli3;生成配置文件;🎉 Successfully created project testvuecli3. At 22:35; 完毕 at 22:35;","tags":[{"name":"Bug","slug":"Bug","permalink":"http://example.com/tags/Bug/"}]},{"title":"WebPack配置文件抽离存放","date":"2021-05-24T07:16:34.000Z","path":"2021/05/24/WebPack配置文件抽离存放/","text":"一、安装插件&amp;配置通常会分离为三个文件,一个开发时依赖的配置文件(这里我命名为dev.config.js),一个发布时依赖的配置文件(这里我命名为prod.config.js),还有一个两模式下都需要依赖的配置文件(这里我命名为base.config.js); 安装插件没错,这个活webpack还是干不了.webpack-merge协助对两个配置文件进行合并. 1npm i webpack-merge -D 该插件在使用时需要导入: 1const webpackMerge = require(&#x27;webpack-merge&#x27;) 二、抽离存放抽离存放可以,但是用的时候也不能让webpack找不着; 1.分离配置文件123456789101112131415161718192021222324252627282930313233343536373839//这是webpack.config.js的内容module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;built.js&#x27;, path: resolve(__dirname, &#x27;build&#x27;) &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;, &#123; exclude: /\\.(css|js|html|less)$/, loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;[hash:10].[ext]&#x27; &#125;, &#125;, &#123; test: /\\.html$/, loader: &#x27;html-loader&#x27; &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;./src/index.html&#x27; &#125;) ], mode: &#x27;development&#x27;, devServer: &#123; contentBase: resolve(__dirname, &#x27;build&#x27;), compress: true, prop: 3000 &#125;&#125;; 仅生产环境下需要的配置放到prod.config.js 12345678//这是prod.config.js的内容module.exports = &#123; devServer: &#123; contentBase: resolve(__dirname, &#x27;build&#x27;), compress: true, prop: 3000 &#125;&#125; 开发环境&生产环境下均需要的配置放到base.config,js 1234567891011121314151617181920212223242526272829//这是base.config,js的内容module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;built.js&#x27;, path: resolve(__dirname, &#x27;build&#x27;) &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;, &#123; exclude: /\\.(css|js|html|less)$/, loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;[hash:10].[ext]&#x27; &#125;, &#125;, &#123; test: /\\.html$/, loader: &#x27;html-loader&#x27; &#125; ] &#125;, mode: &#x27;development&#x27;,&#125;; 到此,我们已经把webpack.config.js分开为三个文件,你可以删除原本的webpack.config.js了. baseConfig合并于prodConfig内,所以接下来仅需要进行dev.config.js和prodConfig的合并","tags":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"}]},{"title":"Webpack dev-server搭建本地服务","date":"2021-05-24T05:25:21.000Z","path":"2021/05/24/dev-server搭建本地服务/","text":"一、安装&amp;配置dev-server安装呼出终端输入指令; 1npm i webpack-dev-server -D 为了防止跟其他插件不兼容,还是记得规定下版本;这里不推荐高版本,会出现与webpack-cli不兼容;配置在webpack.config.js中添加devserver对象进行配置,对象内可设置属性:|属性| 作用 ||–|–|| contentBase | 为哪个文件夹提供服务,默认是webpack.config.js所在的根文件夹. ||port| 端口号,你可以在哪个端口看到效果,默认8080端口; ||inline| 是否实时监听,页面实时刷新,布尔值; ||historyApiFallback| 在SPA页面中.依赖HTML5的history模式; ||compress| 啓動gzip壓縮,讓代碼體型更小,速度更快,布尔值; |示例: 123456mode: &#x27;development&#x27;,devServer: &#123; contentBase: resolve(__dirname, &#x27;build&#x27;), compress: true, prop: 3000&#125; 二、使用dev-server我使用的是VSCode,在终端启用本地服务:webpack-dev-server(更高版本使用npx webpack-dev-server或npx webpack serve); 在package.json中设置”dev”:”webpack-dev-server –open”这样启动本地服务只需:npm run dev,启动服务同时会直接打开浏览器显示效果.当然去掉”–open”也可以,不会自启浏览器,启动仍可以简化成npm run dev;","tags":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"}]},{"title":"Auto.js 控件属性缺失时获取控件","date":"2021-05-22T16:24:12.000Z","path":"2021/05/23/Auto.js 控件属性缺失时获取控件/","text":"群里有很多新人问,各种既没有id也没有text的控件无法获取的问题. 使用环境我们在使用Auto.js Pro进行脚本开发时经常遇到多个页面控件(甚至所有)无id无text,我一开始也很懵,直接使用click()方法又显得很low.但他们的className通常是有的,而且会重名.其他属性也会有不同.","tags":[{"name":"Auto.js","slug":"Auto-js","permalink":"http://example.com/tags/Auto-js/"}]},{"title":"使用WebPack打包CSS文件","date":"2021-05-15T13:37:05.000Z","path":"2021/05/15/使用WebPack打包CSS文件/","text":"一、建立并配置文件webpack.config.js配置文件webpack.config.js用于为webpack分派工作(应该说是告诉它怎么做这个事儿);这个文件大致分成前后两部分,前面各种语句利用Node来获取module exports中需要的属性值之类;后一部分就是module exports这个对象(commonJS使用module exports进行暴露),这个对象是webpack的”工作指南”. 2.引入NodeJS模块获取绝对路径我们需要用绝对路径.不能直接写绝对路径,这里的绝对路径会用于生成webpack处理完后文件的输出路径,如果将来我们对文件路径做出改动,原来的绝对路径会导致输出的位置太远不好被项目中的其他文件引用,或者更惨一点原来的路径断了,打包完根本输出不出来.我们需要一个能跟随webpack.config.js的位置动态改变的绝对路径.Node中有一个path模块,我们可以引入它来提取resolve,resolve是一个方法,专门用于拼接绝对路径.直接在webpack.config,js中写入: 1const &#123;resolve&#125; = require(&#x27;path&#x27;); 之后我们就可以在module exports对象中使用resolve()方法了. 总结提示：这里对文章进行总结：例如：以上就是今天要讲的内容，本文仅仅简单介绍了pandas的使用，而pandas提供了大量能使我们快速便捷地处理数据的函数和方法。","tags":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"}]},{"title":"You may need an appropriate loader to handle this file type","date":"2021-05-10T06:03:06.000Z","path":"2021/05/10/Webpack執行打包“You may need an appropriate loader to handle this file type“/","text":"问题描述：配置webpack.config.js完成;webpack &amp; webpack-cli安裝完成;css-loader &amp; style-loader安裝到上級文件夾完成,執行打包時輸入webpack顯示如下:也沒有生成Hash值“您或許需要loader來處理這種類型的文件”,但我已經安裝了正確的loader.","tags":[{"name":"Bug","slug":"Bug","permalink":"http://example.com/tags/Bug/"}]},{"title":"Vue组件传值(一) props父传子","date":"2021-04-25T14:34:23.000Z","path":"2021/04/25/Vue组件传值(一) props父传子/","text":"甚麽是Vue组件，为甚麽采用组件化？我想，如果您已经接触过一些Vue组件化开发的基础知识，您便可以略过这段了。关于Vue组件：在开发过程中，如果把需要重复使用的一段框架封装起来，并且能在后面的使用中以极其简便的方式调用（自然是极少能遇到需要框架内容完全相同的情况，后面会有slot插槽的方法来改动需要变化的地方）一定会很方便，于是产生了“Vue组件”这一概念。听到上面说的Vue组件的用法，您会觉得它很像一种“模板”？其实Vue组件的构成中最重要的一部分就是模板属性“template”，它支持您在Vue组件模板对象中书写您需要的框架。关于组件化开发：其实组件的优点应该放在这里一并说，组件这一概念诞生后，服务器的压力相比以前已经有所改善，但是明显是仍有改进空间的：每个组件都要请求一份属于自己的数据，在数据更新后还要再次请求，出现事件要反馈…… 解决这个问题的途径便是将页面分割为一个个大组件，其内部装载各种子组件，如此一来，大组件只要在请求数据时把子组件的数据也都请求回来等着子组件调用即可，这就缩减了请求总次数。 一、在Vue组件间传输数据的目的前面说到父组件会在请求数据时顺带把子组件的数据也请求回来等待调用，那么既然子组件要调用，也就需要在Vue组件层面进行数据传输，子组件在自身事件触发后也要向服务器提交报告（内部包含触发的事件和触发事件的数据位置），这一过程也要经过父组件。 总结2021.7.27 这个Vue传值系列打算持续更了,后面我会带来更多的传值方式,今天刚把这 $emit重写完,新文章也请您多多照顾哈哈.$emit的文章传送门:Vue组件传值(二) $emit子传父&amp;事件触发","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"对前后端的理解","date":"2021-04-17T10:27:00.000Z","path":"2021/04/17/对前后端的初步理解/","text":"一、写在甚麽地方？怎么配合其他代码？1.在PHP文档里写PHP放在专门的后缀为“.php”的文件里。 2.在HTML文档里写PHP或者你可以把它放在你的前端HTML文档中但是你必须把它放在“”内部，只有那里面能写PHP代码,其他的各写各的，互不干扰，您只要记住php要写在这里面就好了。 像是这样： 1234567891011121314151617181920212223&lt;?php//连接数据库$link = mysql_connect(&quot;localhost&quot;, &quot;username&quot;, &quot;password&quot;)or die(&quot;Could not connect: &quot; . mysql_error());print (&quot;Connected successfully&quot;);//选择数据库mysql_select_db(&#x27;dbname&#x27;, $link) or die (&#x27;Can\\&#x27;t use db : &#x27; . mysql_error());//进行你想要的操作$a =123;?&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;发现I Do一刻&lt;/title&gt;&lt;link href=&quot;css/public.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;&lt;script src=&quot;Scripts/AC_RunActiveContent.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;?phpecho $a;?&gt;&lt;/body&gt;&lt;/html&gt; 3.在PHP文档里写HTML不太一样的是在PHP文档里对HTML框架进行填充时，要采用如下格式：‘HTML内容’ . PHP内容. ‘HTML’内容‘ 看着不太好明白，实际上就是HTML部分作为字符串的形式引入PHP文档中。PHP文档也能解析html代码,这些html代码会跟随着PHP文档在服务端执行。但是要填充HTML框架，HTML语法需要作为字符串和php语句进行字符串拼接，用php拿来的数据对HTML进行填充。在PHP中，字符串拼接使用小数点而不是加号。 ## 3.PHP 的 数组 PHP中两种数组： 1234//这是一个具有三个数组元素，使用array函数生成的普通数组; $数组名 = array(&#x27;ele1&#x27;, &#x27;ele2&#x27;,&#x27;ele3&#x27;); echo $数组名[索引号]; //输出数组中某个元素; print_r($数组名）; //输出一整个数组; 1234//这是一个具有三个数组元素，使用array函数生成的索引数组; $数组名 = array(&#x27;key1&#x27; =&gt; &#x27;value1&#x27;, &#x27;key2&#x27; =&gt; &#x27;value2&#x27;, &#x27;key3&#x27; =&gt; &#x27;value3&#x27;); echo $数组名[&#x27;key名&#x27;]; //输出数组中某个key对应的value; print_r($数组名）; //输出一整个数组; 以上是两种常用的数组类型，再此基础上还可拓展出二维数组、三维数组、再向更高维度的数组用的比较少了。 数组遍历从下面开始要涉及到“$ key 和 $ value”，这两个变量是为了好理解才命名为”key”和“value”的，数组内的key会经过$ key变量，而value会经过$ value变量，您尽可以把它们换成乱七八糟的名字，只要在那个位置有这么两个变量，循环就会知道该干什么。JS中的循环遍历数组提取数组内容的方法在PHP中依然存在使用for循环，或者foreach来进行。count()函数用在for遍历中，可以取到数组的长度。 1234//for循环遍历数组，count($数组名)表示取到该数组的元素个数;for($i = 0; $i &lt; count($数组名); $i++) &#123; echo $数组名[$i];&#125; foreach遍历： 12foreach ($数组名 as $value) //方法一;foreach($数组名 as $key =&gt; $value) //方法二; 第一种foreach方法遍历数组的原理：在遍历进行至每个索引单元（数组元素）时，都将这个索引单元的value（即键对应的值）赋值给变量$ value，并且数组内部的指针向前移一步来进入下一个索引单元。第二种foreach方法遍历数组的原理：在遍历进行至每个索引单元（数组元素）时，都将这个索引单元的key（即键名）赋值给变量$ key（这样说很难理解，其实$ key完全可以改成“$i”,相当于for循环中的 i），并且数组内部的指针向前移一步来进入下一个索引单元。 两种方法实际上一个是利用键来遍历，一个利用值来遍历。foreach输出索引数组的内容： 1234foreach($数组名 as $value) &#123; each $value.&quot;&lt;br&gt;&quot;;&#125;//数组的各个key对应的值value会被输出; 总结码了一个下午……您要是觉得还可以就点个赞吧 ：·）感觉写的还是有点粗略，因为我对PHP并没有太多研究，我举的例子有点以偏概全的感觉。以后有计划把HTML里写PHP获取HTML页面信息的那块仔细说说。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"Vue v-for指令使用指南","date":"2021-04-15T05:07:19.000Z","path":"2021/04/15/v-for指令使用指南/","text":"与for循环的功能相似，以第一个元素作为模板生成后续，内部的子元素也会被生成。 一、v-for利用数组生成元素利用v-for从数组获取数据基本的模式：仅获取未做处理的数组元素： 1&lt;li v-for=&quot;用以获取数组元素的自定义变量 in 数组名&quot;&gt;&#123;&#123;用以获取数组元素的自定义变量&#125;&#125;&lt;/li&gt; 获取未处理的数组元素&amp;各自的索引号： 1&lt;li v-for=&quot;(用以获取数组元素的自定义变量，用来获取索引号的变量) in 数组名&quot;&gt;&#123;&#123;用以获取数组元素的自定义变量&#125;&#125;&#123;&#123;用来获取索引号的变量&#125;&#125;&lt;/li&gt; 先写个例子吧： 1234567891011121314151617181920&lt;!--纯数组arr、内部有对象的数组objArr--&gt; const app = new Vue(&#123; el: &#x27;ul&#x27;, data: &#123; arr: [1, 2, 3, 4, 5], objArr: [ &#123; id: 1, name: &#x27;a1&#x27;, hobby: &#x27;a2&#x27;, &#125;, &#123; id: 2, name: &#x27;b1&#x27;, hobby: &#x27;b2&#x27;, &#125;, &#x27;meaasge1&#x27; ] &#125; &#125;) 一、直接获取数组内的元素这意味着数组内的对象会直接被整个提取出来： 123&lt;ul&gt; &lt;li v-for=&quot;item in objArr&quot;&gt;&#123;&#123;i&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 123&lt;ul&gt; &lt;li v-for=&quot;i in objArr&quot;&gt;&#123;&#123;i&#125;&#125;&lt;/li&gt;&lt;/ul&gt; “in”前面的变量相当于for循环中的i，是可以自定义的，以上两段代码输出结果同为： 二、获取数组内对象的属性值可以看到在上面的i里我们已经获取到了数组objArr里的所有元素，那么只需要在插值表达式上做些改动即可： 1234&lt;ul&gt; &lt;li v-for=&quot;i in objArr&quot;&gt;&#123;&#123;i.name&#125;&#125;&lt;/li&gt; //获取所有对象里的name属性;&lt;/ul&gt; 三、获取数组元素的索引号Vue对象里的数组内本身具有索引号，但是要绑定到一个变量才能获取出来，每个数组元素都要绑定一个这个变量里的索引号，然后在获取这个数组元素的时候把与它绑定的索引号获取出来：绑定变量index到各个数组元素： 123&lt;ul&gt; &lt;li v-for=&quot;(i,ind) in objArr&quot;&gt;&#123;&#123;ind&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 123&lt;ul&gt; &lt;li v-for=&quot;(i,index) in objArr&quot;&gt;&#123;&#123;index&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 两个变量ind、index获取到的索引号是相同的： 二、v-for利用对象生成元素利用v-for从对象中获取数据基本的模式与从数组中获取很相似：仅获取属性值： 1&lt;li v-for=&quot;用以获取属性值的自定义变量 in 对象名&quot;&gt;&#123;&#123;用以获取属性值的自定义变量&#125;&#125;&lt;/li&gt; 获取属性值&amp;属性名： 1&lt;li v-for=&quot;(用以获取属性值的自定义变量,用以获取属性名的自定义变量) in 对象名&quot;&gt;&#123;&#123;用以获取属性值的自定义变量&#125;&#125;&#123;&#123;用以获取属性名的自定义变量&#125;&#125;&lt;/li&gt; 拿这个Vue对象作为例子吧： 123456789101112131415const app = new Vue(&#123; el: &#x27;ul&#x27;, data: &#123; obj1: &#123; id: 1, name: &#x27;a1&#x27;, hobby: &#x27;a2&#x27;, &#125;, obj2: &#123; id: 2, name: &#x27;b1&#x27;, hobby: &#x27;b2&#x27;, &#125;, &#125;&#125;) 一、仅获取对象中属性的值值通常比属性重要，所以第一个变量默认获取的是值。完成利用v-for对对象值的获取，意味着您可以在这个元素的插值表达式里使用这些对象值对应的变量，以此来把这些值填充进生成的元素里。 1234&lt;ul&gt; &lt;li v-for=&quot;value in obj1&quot;&gt;&#123;&#123;value&#125;&#125;&lt;/li&gt; //“value”所在的位置是一个可自定义变量名的变量。&lt;/ul&gt; 输出结果如下，为对象obj1里的三个属性值：二、获取对象中的属性值和属性名利用v-for获取对象中的属性名和属性值。这意味着您可以在这个元素的插值表达式内使用您获取到的属性名和属性值。 123 &lt;ul&gt; &lt;li v-for=&quot;(value,key) in obj1&quot;&gt;&#123;&#123;value&#125;&#125; &amp; &#123;&#123;key&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 此处value作为要用来获取对象属性值的变量；key作为用来获取属性名的变量；输出结果如下：","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"Webpack:“WARNING in configuration The ‘mode‘ option hasnot been set, webpack will fallback .... “","date":"2021-04-14T14:20:42.000Z","path":"2021/04/14/Webpack“WARNING in configuration The ‘mode‘ option hasnot been set, webpack will fallback .... “/","text":"问题描述：配置webpack.config.js完成;webpack &amp; webpack-cli安裝完成;css-loader &amp; style-loader安裝到上級文件夾完成,執行打包時輸入webpack顯示如下:提示我沒有配置mode項 解决方案：解決方案一是剛開始用的,後來無意間發現了第二種:解決方案一:此時webpack為最新版5.36.2,需要在打包指令”webpack”后添加後綴 “–mode=development”來解決. 解決方案二:在使用一解決後我繼續完成後續工作,卡在css文件打包的問題上,最後我選取了webpack5.0.0webpack-cli3.3.12style-loader1.1.3css-loader3.6.0這一能配合webpack5.0.0的組合來進行最後的打包,發現在這種包組合下直接執行”webpack”即可進行正常打包.","tags":[{"name":"Bug","slug":"Bug","permalink":"http://example.com/tags/Bug/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Vue生命周期解析","date":"2021-04-14T14:20:42.000Z","path":"2021/04/14/Vue生命周期解析/","text":"前言升学，找工作，失业，找工作，买房，成家，一些人甚至至死都没能跑完这条人生的长路，他们的一生在奔波中度过，却不曾看到过一丝沿途的风景。 Vue是一个这样的人，在他短暂而被安排的明明白白的人生路途中，只剩下奔波，沿途的风景未能让他驻足一瞬，他创造的诸多美好，却从无法看哪怕是一眼。 狗头) 一、甚麽是[Vue的生命周期]？Vue的每个组件都是独立的，正因如此，Vue的每个组件也都有各自的生命周期（就像人的肺和肾都有自己的寿命），他们共同组成了[Vue的生命周期]。 Vue并不像人的生命周期一样有生老病死，如果Vue对象不被销毁，Vue会一直在那里，所以“生命周期”这个词在此处大可不必完全解读为“生命周期”原本的意思，知道是Vue创立后固定要做的那么些事儿就好了。 二、生命周期函数有时我们需要在Vue执行到某一步时，执行某些操作，那么可以利用这些生命周期函数来完成，把要执行的命令写进这些生命周期函数里，在Vue执行到这些函数的所在时，就会顺带完成你需要的操作，而我们首先要知道这些周期函数在什么时候会被执行、他们都是哪些。 1.beforeCreate在示例初始化、data observer配置和事件配置完成之间调用 2.created初始化依赖和注入，data初始化完毕，计算属性和event/watch事件进行回调后，DOM树挂载前。通常会在此处进行一部分网络请求。 3.beforeMount挂载前，创建虚拟el前，生成模板template后。 4.mounted挂载完成，DOM树渲染完毕后。 5.beforeDestoryVue实例销毁前。 6.destoryedVue所有子组件销毁后。 7.beforeUpdate数据data有更新，已被调用后。 8.updated虚拟DOM重新渲染发生变化的数据。 123456789101112131415161718192021222324252627282930Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const restoreActiveInstance = setActiveInstance(vm) vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) &#125; restoreActiveInstance() // update __vue__ reference if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125; // updated hook is called by the scheduler to ensure that children are // updated in a parent&#x27;s updated hook.&#125; 三、Vue的一生要做些甚麽？1.Vue对象创立，Vue出生。构造函数生成Vue实例； 1new Vue(); 2.初始化原步骤Init Event&Lifecycle;初始化事件相关：Event;初始化各生命周期函数：Lifecycle（也叫钩子函数）； 123import &#123; initEvents &#125; from &#x27;./events&#x27;import &#123; mark, measure &#125; from &#x27;../util/perf&#x27;import &#123; initLifecycle, callHook &#125; from &#x27;./lifecycle&#x27; 1234567891011121314151617181920212223242526//src/core/instance/lifecycle.jsexport function initLifecycle(vm: Component) &#123; const options = vm.$options // locate first non-abstract parent let parent = options.parent if (parent &amp;&amp; !options.abstract) &#123; while (parent.$options.abstract &amp;&amp; parent.$parent) &#123; parent = parent.$parent &#125; parent.$children.push(vm) &#125; vm.$parent = parent vm.$root = parent ? parent.$root : vm vm.$children = [] vm.$refs = &#123;&#125; vm._watcher = null vm._inactive = null vm._directInactive = false vm._isMounted = false vm._isDestroyed = false vm._isBeingDestroyed = false&#125; 以上为对生命周期函数lifecycle的初始化 12345678910//src/coreinstance/event.jsexport function initEvents (vm: Component) &#123; vm._events = Object.create(null) vm._hasHookEvent = false // init parent attached events const listeners = vm.$options._parentListeners if (listeners) &#123; updateComponentListeners(vm, listeners) &#125;&#125; 以上为对事件Event的初始化 123456789101112131415export function callHook(vm: Component, hook: string) &#123; // #7573 disable dep collection when invoking lifecycle hooks pushTarget() const handlers = vm.$options[hook] const info = `$&#123;hook&#125; hook` if (handlers) &#123; for (let i = 0, j = handlers.length; i &lt; j; i++) &#123; invokeWithErrorHandling(handlers[i], vm, null, vm, info) &#125; &#125; if (vm._hasHookEvent) &#123; vm.$emit(&#x27;hook:&#x27; + hook) &#125; popTarget()&#125; 以上为调用钩子函数Hook 2.5BeforeCreated函数调用生命周期函数BeforeCreated被调用。 12//src/core/instance/init.js callHook(vm, &#x27;beforeCreate&#x27;) 3.继续初始化原步骤Init injections &amp; reactivity &amp; state初始化依赖提供：provide；初始化依赖注入：injections；初始化Vue响应式的核心：reactivity ；provide提供依赖，提供的依赖可以是一个对象，或者是一个能返回对象的函数。依赖内包含了属性和属性值，属性值可以是一个对象。injections 注入依赖，在后代组件里使用 inject 选项来为其注入需要添加在这个实例上的属性，包含from和default默认值。reactivity系列是Vue响应式的核心。需要调用以上函数 1234567891011121314151617181920212223242526272829303132//src/core/instance/inject.jsexport function initProvide (vm: Component) &#123; const provide = vm.$options.provide if (provide) &#123; vm._provided = typeof provide === &#x27;function&#x27; ? provide.call(vm) : provide &#125;&#125;export function initInjections (vm: Component) &#123; const result = resolveInject(vm.$options.inject, vm) if (result) &#123; toggleObserving(false) Object.keys(result).forEach(key =&gt; &#123; /* istanbul ignore else */ if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; defineReactive(vm, key, result[key], () =&gt; &#123; warn( `Avoid mutating an injected value directly since the changes will be ` + `overwritten whenever the provided component re-renders. ` + `injection being mutated: &quot;$&#123;key&#125;&quot;`, vm ) &#125;) &#125; else &#123; defineReactive(vm, key, result[key]) &#125; &#125;) toggleObserving(true) &#125;&#125; 以上为初始化依赖提供provide与依赖注入injections 12345678910111213141516//src/core/instance/state.jsexport function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 以上为初始化state 3.5Create函数调用生命周期函数Create被调用。此段出自Vue源码文件”init.js” 4.判断el是否挂载了DOM没有挂载就挂载一个。有就直接下一步。watch事件回调this._init末的$mount函数运作。 12345678//src/platform/web/runtime/index.jsVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125; 以上为$mount函数的基本模型 123456789101112131415//src/platform/web/entry-runtime-with-compiler.jsVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; query(el) /* istanbul ignore if */ if (el === document.body || el === document.documentElement) &#123; process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn( `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.` ) return this &#125; 以上为Vue中的$mount函数被调用 1234567891011121314151617181920212223Vue.prototype.$watch = function ( expOrFn: string | Function, cb: any, options?: Object): Function &#123; const vm: Component = this if (isPlainObject(cb)) &#123; return createWatcher(vm, expOrFn, cb, options) &#125; options = options || &#123;&#125; options.user = true const watcher = new Watcher(vm, expOrFn, cb, options) if (options.immediate) &#123; try &#123; cb.call(vm, watcher.value) &#125; catch (error) &#123; handleError(error, vm, `callback for immediate watcher &quot;$&#123;watcher.expression&#125;&quot;`) &#125; &#125; return function unwatchFn () &#123; watcher.teardown() &#125;&#125; $watch被调用 5.判断是否有模板模板template作为模板占位符，用来包裹HTML元素，其不会被渲染到页面上，可以有三种写法：作为option属性写在Vue对象里、直接作为HTML标签、写在script标签里（第三个官方推荐写法,为script标签里的type属性赋值”x-template”）。有template模板把模板template转换为render函数（render函数会在后续渲染DOM中发挥作用）。无template模板将el挂载的对象的外层HTML作为模板template。没有对象就new一个啊（不是）this._init末的$mount函数运作完毕。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//src/platform/web/entry-runtime-with-compiler.js const options = this.$options // resolve template/el and convert to render function if (!options.render) &#123; let template = options.template if (template) &#123; if (typeof template === &#x27;string&#x27;) &#123; if (template.charAt(0) === &#x27;#&#x27;) &#123; template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !template) &#123; warn( `Template element not found or is empty: $&#123;options.template&#125;`, this ) &#125; &#125; &#125; else if (template.nodeType) &#123; template = template.innerHTML &#125; else &#123; if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; warn(&#x27;invalid template option:&#x27; + template, this) &#125; return this &#125; &#125; else if (el) &#123; template = getOuterHTML(el) &#125; if (template) &#123; /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(&#x27;compile&#x27;) &#125; const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123; outputSourceRange: process.env.NODE_ENV !== &#x27;production&#x27;, shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this) options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(&#x27;compile end&#x27;) measure(`vue $&#123;this._name&#125; compile`, &#x27;compile&#x27;, &#x27;compile end&#x27;) &#125; &#125; &#125; return mount.call(this, el, hydrating)&#125; 判断是否具有模板template，若是无模板template就将外层HTML转换为template; 5.5beforeMount函数调用生命周期函数beforeMount被调用。 5.6前面生成的render函数被调用render函数被调用来生成虚拟DOM，虚拟DOM是渲染好的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Vue.prototype._render = function (): VNode &#123; const vm: Component = this const &#123; render, _parentVnode &#125; = vm.$options if (_parentVnode) &#123; vm.$scopedSlots = normalizeScopedSlots( _parentVnode.data.scopedSlots, vm.$slots ) &#125; // set parent vnode. this allows render functions to have access // to the data on the placeholder node. vm.$vnode = _parentVnode // render self let vnode try &#123; vnode = render.call(vm._renderProxy, vm.$createElement) &#125; catch (e) &#123; handleError(e, vm, `render`) // return error render result, // or previous vnode to prevent render error causing blank component /* istanbul ignore else */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; vm.$options.renderError) &#123; try &#123; vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) &#125; catch (e) &#123; handleError(e, vm, `renderError`) vnode = vm._vnode &#125; &#125; else &#123; vnode = vm._vnode &#125; &#125; // if the returned array contains only a single node, allow it if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) &#123; vnode = vnode[0] &#125; // return empty vnode in case the render function errored out if (!(vnode instanceof VNode)) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; Array.isArray(vnode)) &#123; warn( &#x27;Multiple root nodes returned from render function. Render function &#x27; + &#x27;should return a single root node.&#x27;, vm ) &#125; vnode = createEmptyVNode() &#125; // set parent vnode.parent = _parentVnode return vnode&#125; 以上为对render函数的调用 6.虚拟el创建，DOM替换原步骤Create vm $el and replace “el” with it.Vue实例下的虚拟el创建，虚拟DOM替换原本的DOM。 -render方法在此处运作生成虚拟DOM对象。 6.5.DOM树渲染至页面完毕虚拟DOM挂载完毕，DOM树已经成功渲染至页面，页面已经具有样式，可以进行正常DOM操作。 7.Mounted函数调用。生命周期函数Mounted调用。 8.准备完毕Mounted状态如果在这个状态出现了数据更新需要再次渲染来更新页面：生命周期函数BeforeUpdate调用；虚拟DOM重新渲染，但仅以最小的DOM开支渲染发生变化的部分，其他部分复用，节省工作量。 9.Vue实例被请求销毁9.5BeforeDestory函数调用生命周期函数BeforeDestory调用。 10.清除各Vue组件清除watchers、child子组件、components和eventlistener事件监听 等等…… 12345678910111213141516171819202122232425262728293031323334353637383940414243 Vue.prototype.$destroy = function () &#123; const vm: Component = this if (vm._isBeingDestroyed) &#123; return &#125; callHook(vm, &#x27;beforeDestroy&#x27;) vm._isBeingDestroyed = true // remove self from parent const parent = vm.$parent if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) &#123; remove(parent.$children, vm) &#125; // teardown watchers if (vm._watcher) &#123; vm._watcher.teardown() &#125; let i = vm._watchers.length while (i--) &#123; vm._watchers[i].teardown() &#125; // remove reference from data ob // frozen object may not have observer. if (vm._data.__ob__) &#123; vm._data.__ob__.vmCount-- &#125; // call the last hook... vm._isDestroyed = true // invoke destroy hooks on current rendered tree vm.__patch__(vm._vnode, null) // fire destroyed hook callHook(vm, &#x27;destroyed&#x27;) // turn off all instance listeners. vm.$off() // remove __vue__ reference if (vm.$el) &#123; vm.$el.__vue__ = null &#125; // release circular reference (#6759) if (vm.$vnode) &#123; vm.$vnode.parent = null &#125; &#125;&#125; $destory清除实例里的方法 11.组件销毁完毕12.Destory函数调用生命周期函数Destory调用。 至此Vue的一段生命周期便执行完成，它完成了它的使命，暂时。 总结今天先告一段落…终于考完试了！打算下面几天都拿来肝文了！已经加入一些Vue源码片段来展示各个生命周期函数：~），我依然在完善这篇文章，部分代码尚未找到，所以后续还会有增加…","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"CSS动画构成解剖","date":"2021-03-28T14:35:29.000Z","path":"2021/03/28/解剖CSS动画/","text":"","tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"let、const与块级作用域","date":"2021-03-08T13:52:46.000Z","path":"2021/03/08/let、const与块级作用域/","text":"","tags":[{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"}]},{"title":"XMLHttpRequest对象解读&AJAX使用","date":"2021-02-25T14:38:00.000Z","path":"2021/02/25/XMLHttpRequest对象解读&AJAX使用/","text":"","tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/tags/AJAX/"}]},{"title":"浏览器缓存机制","date":"2021-02-24T18:09:52.000Z","path":"2021/02/25/浏览器Cache机制/","text":"","tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"JavaScript正则表达式（1）","date":"2021-02-23T19:51:51.000Z","path":"2021/02/24/JavaScript正则表达式（1）/","text":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"Vue-cli4.x 中的全局样式配置","date":"2021-02-23T19:51:51.000Z","path":"2021/02/24/Vue-cli 4.x 中的全局样式配置/","text":"一、插件准备你需要安装3个插件: dart-sass &amp; sass-resources-loader &amp; sass-loader安装dart-sass &amp; sassresource-loader 1234npm install sass sass-loader -D//这个指令会安装dart-sass和sass-loader;//node-sass安装中经常出现各种问题;//性能也比不上dart-sass,在2020年末被替代; 安装sass-resources-loader 12npm i sass-resources-loader -D//ver2.2.2,当前的最新版; 我的配置信息: 二、开始配置1.vue.config.js配置你可能已经发现在vue-cli4.x创建的项目中不再有config和dist了,对,所有的配置我们都要在vue.config.js中完成.那么,在项目目录下直接创建vue.config.js,然后进入下一步. 12345678910111213module.exports = &#123; publicPath: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;&#x27; : &#x27;/&#x27;, outputDir: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;dist&#x27; : &#x27;devDist&#x27;, lintOnSave: false, css: &#123; loaderOptions: &#123; scss: &#123; AdditionalData: `@import &quot;./src/style/main.scss&quot;;` /*ver8.x改为prependData: `@import &quot;./src/style/main.scss&quot;;`,运行时请去掉本注释 */ &#125; &#125; &#125;&#125; 因为我们现在只配置全局scss需要的配置,那…..我就只写这一部分需要的配置了,如果想一步到位的话CSDN搜索vue-cli4 vue.config.js配置即可. .App.vue配置很简单的一步,在App.vue的&lt; style &gt;标签中加入lang属性: 1&lt;style lang=&quot;scss&quot;&gt; 即可. 好吧,我们在全局scss文件里随便写点什么: 1234body &#123; background-color: rgb(177, 60, 82);&#125; 到此说明我们的全局scss文件引入成功了.","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]},{"title":"JavaScript数据类型","date":"2021-02-06T17:29:42.000Z","path":"2021/02/07/JavaScript数据类型/","text":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JS预解析机制","date":"2020-12-06T15:14:40.000Z","path":"2020/12/06/JavaScript预解析机制/","text":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"CSS的三大特性","date":"2020-11-27T02:30:56.000Z","path":"2020/11/27/CSS的三大特性/","text":"下面我会依次阐述这三种特性使用时的注意事项与方法。 一、CSS层叠性在对一个元素所设置的多个不同选择器 或者 一个选择器内，对同一样式不同的值，会造成样式冲突，此时需要考虑CSS的层叠性，CSS将根据层叠特性来决定使用哪种样式。 特性简述：当出现上述情况时，CSS将会采用距离目标元素的代码最近的样式，就近原则。如下所示： 123456&lt;style&gt; div &#123; background-color: yellow; background-color: skyblue; &#125;&lt;/style&gt; 1234&lt;body&gt; &lt;div&gt;示例：CSS层叠性&lt;/div&gt;&lt;/body&gt; 依据上述，以上代码显示出盒子的颜色应当为天蓝色。以下为另一种情况： 12345678&lt;style&gt; div &#123; background-color: skyblue; &#125; div &#123; background-color: yellow; &#125;&lt;/style&gt; 这段代码的运行结果为黄色，下方控制黄色的选择器距离目标元素更近。 二、CSS继承性在对子级标签的样式进行设置时需要注意，其会继承其父标签中部分能被其自身继承的样式，而且“继承父元素样式”被使用的优先级低于“使用该元素被直接设定的样式”，恰当的利用这一特性可以缩减代码量，例如对多个同父子元素内字体与背景色的设置，就可以直接为其父元素设置样式，使所有子标签样式相同。 1234567891011&lt;style&gt; div &#123; color: skyblue; font-size: 15px; &#125; #继承性2 &#123; color: yellow; font-size: 30px; &#125;&lt;/style&gt; 12345678&lt;body&gt; &lt;div&gt; &lt;p&gt;示例：CSS继承性1&lt;/p&gt; &lt;p id=&quot;继承性2&quot;&gt;示例：CSS继承性2&lt;/p&gt; &lt;p&gt;示例：CSS继承性3&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 这段代码运行后，显示效果如下可以看到的是子级元素继承了父级元素的样式，但出现针对自己的样式时依然会优先使用自己专属的样式（跟能叫外卖就不会去食堂吃大锅菜是一样的）。 三、CSS优先级前面在说到CSS选择器的时候我说到了CSS的权重、优先级相关，这里也算是对那节内容的补充吧。在选择器相同的时候将需要考虑我们前面说的“层叠性”特性，而当选择器不同时，将需要考虑CSS的“优先级“特性。“选择器权重”这一概念是被“优先级”这一概念包含在内的。|选择器|选择器权重 ||–|–|| 继承或 *全选 | 0，0，0，0||元素选择器|0，0，0，1 ||类选择器、伪类选择器|0，0，1，0|ID选择器|0，1，0，0|| 继承或 *全选 | 0，0，0，0||行内样式style=” “|1，0，0，0 ||!important 重要|无穷大| 这些权重值基本可以看作数学数值个十百千，理所当然的是占位越高权重越大，在多个可选的选择器内，权重大的选择器将会被优先采用，而若是在样式后跟上!important，则选择器必定被采用，因其权重为“无限大”。下面请看一个示例： 123456789101112131415&lt;style&gt; div &#123; color: grey; font-size: 15px; &#125; #优先级 &#123; color: yellow; font-size: 30px; &#125; .示例 &#123; background-color: skyblue; &#125;&lt;/style&gt; 123&lt;body&gt; &lt;div class=&quot;示例&quot; id=&quot;优先级&quot;&gt;示例：优先级&lt;/div&gt;&lt;/body&gt; 若是按照“层叠性”的就近原则，此处应当采用class=”示例”设置的样式，但此处的选择器众多，应当参照“优先级”特性而非“层叠性”特性；ID选择器因为在所示三种选择器中为权重最高(0,1,0,0)的一种，所以即便在中间放置也依然被优先采用了。看下!important的用法： 123456789101112&lt;style&gt; div &#123; color: grey!important; font-size: 30px; &#125; #优先级 &#123; color: yellow; font-size: 50px; &#125;&lt;/style&gt; 123&lt;body&gt; &lt;div class=&quot;示例&quot; id=&quot;优先级&quot;&gt;示例：优先级&lt;/div&gt;&lt;/body&gt; 还是刚才的HTML代码，这次我为标签选择器中的颜色样式添加了!important，那么是否整个标签选择器的样式都会被采用？并没有，标签选择器中的颜色样式因为加大权重被使用，而标签选择器中的其他属性（比如设置的字号）并不能被采用，!important仅能加强某个样式属性的权重，并不能加强整个选择器的权重。 总结 以上便是CSS三大特性的相关，在下独自整理，可能并不全面，如果有帮助到您，在下荣幸之至，如果您发现了我的错误与缺陷，在下恳请您的指点，多谢！","tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"CSS選擇器的种类&使用","date":"2020-11-21T16:17:55.000Z","path":"2020/11/22/CSS選擇器的种类&使用/","text":"","tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"CSS中position定位属性的使用","date":"2020-11-19T15:02:24.000Z","path":"2020/11/19/CSS中Position定位属性的使用/","text":"","tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"Vue3 插槽使用详解","date":"2020-06-25T15:24:48.000Z","path":"2020/06/25/Vue3插槽使用详解/","text":"前言-认识slot&lt; slot&gt;&lt; /slot&gt;一般被写在子组件里,可以被父组件内写的东西”插”满,把它看作是一个帮 [未来要填充的东西] 提前占位的空框,就像那些一个人占了自习室一整排的可恶的家伙.我想我用程序里的名词来比喻可能比较好理解?slot就像子组件里一个可以传入参数的函数,你可以从父组件里往里传各种标签作为它的参数. 感谢你浪费一分钟生命读完了这段废话,我们开始吧 doge) 动态指令参数与插槽从 2.6.0 开始，可以用方括号括起来的JS表达式作为一个指令(v-bind啥的)的参数,比如在此例中 12//随便定义一个变量randomName,这个变量是动态变化的;&lt;a v-bind:[randomName]=&quot;user&quot;&gt; ... &lt;/a&gt; 或者: 12//对不同的事件绑定处理函数;&lt;a v-on:[randomEventName]=&quot;differentFunction&quot;&gt; ... &lt;/a&gt; 在2.6版本新增的内容中,动态指令参数也可以用在 v-slot 上，来定义动态的插槽名: 123456&lt;base-layout&gt; &lt;template v-slot:[动态指令参数]&gt; /* 动态指令参数,就像前面的randomEventName */ ... &lt;/template&gt;&lt;/base-layout&gt; 总之只要出现使用多个插槽的情况,那就用具名插槽吧!使用&lt; template&gt;来包裹某插槽的填充物,在template标签的v-slot属性后面写上对应插槽的name属性值.先来看看子组件吧: 1234567&lt;template&gt; &lt;div class=&quot;tab-bar-item&quot;&gt; &lt;slot name=&quot;item-icon&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;item-text&quot;&gt;&lt;/slot&gt; &lt;!-- 插槽slot最终会被父组件里传入的html元素替换,在插槽上写样式类的东西不会生效,可以用div来包裹slot,利用样式继承性来完成样式修改 --&gt; &lt;/div&gt;&lt;/template&gt; 父组件: 12345678910111213141516//这是在父组件内 &lt;tab-bar-item&gt; &lt;template v-slot:item-icon&gt; /* !!2.6新增:可简写为&lt;template #item-icon&gt; !!*/ /* 这部分填充入插槽:item-icon */ &lt;img src=&quot;#&quot; /&gt; &lt;/template&gt; &lt;template v-slot:item-text&gt; /* !!2.6新增:可简写为&lt;template #item-text&gt;!! */ /* 这部分填充入插槽:item-text */ &lt;div&gt;首页&lt;/div&gt; &lt;/template&gt; &lt;/tab-bar-item&gt; 这样所有在template包裹下的填充内容都会被填入对应的插槽,但如果没有被template包裹呢?那样就相当于写了个这: 1234&lt;template v-slot:default&gt;/* 隐含的名字“default”(默认) */ &lt;p&gt;我是内容&lt;/p&gt;&lt;/template&gt; Vue官方文档:没有被包裹在带有 v-slot 的 中的内容都会被视为默认插槽的内容.它的填充物的CSS样式将受到父组件的影响. 总结注意 v-slot 只能添加在 上 (只有一种例外情况);我为什么要把这些玩意儿写在插槽里,这么麻烦为什么不直接写那些标签?是,我一开始也在问我自己为什么不直接写标签而要写插槽,跟套娃一样. 后来我意识到这些放在插槽里的东西可以让插槽所在区域的内容动态化,”不写死”的思想又一次在这里得到了体现,只不过这次的变量是插槽里的那段html代码;而且,如果直接向父组件中的子组件里填充html结构,没有slot占位是渲染不出来(无法创建)的(其实在子组件内的slot上写样式也是不行的,slot一旦渲染就会被替换成填充物,自己的样式就跟着一块被替换下去了,啥都看不见,我们得拿个div什么的把slot包起来然后在div上写样式,让样式继承到未来的填充物上. 写了仨小时,回头看了一眼,崩溃了,参考的是2.6的文档.马上滚去看了v3的文档,幸亏差的不多,改动也大多都在v2.6完成了,这波是老天帮忙. 以上是我据本阶段的学习得出的一些经验与心得，如果帮到了您，在下十分荣幸；若是您发现了不足，您可以在评论区指出, 我会感谢您的指点的!","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://example.com/tags/Vue-js/"}]}]